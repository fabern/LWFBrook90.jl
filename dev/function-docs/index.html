<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function Documentations · LWFBrook90.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://fabern.github.io/LWFBrook90.jl/function-docs/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="LWFBrook90.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">LWFBrook90.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">About</a></li><li><a class="tocitem" href="../model/">SVAT Model</a></li><li><a class="tocitem" href="../user-guide/">User Guide</a></li><li><a class="tocitem" href="../example/">Example</a></li><li><a class="tocitem" href="../code-lst/">Code Listing</a></li><li class="is-active"><a class="tocitem" href>Function Documentations</a><ul class="internal"><li><a class="tocitem" href="#Functions-from-file-examples/BEA2016...-input/func_run_example.jl"><span>Functions from file <code>examples/BEA2016...-input/func_run_example.jl</code></span></a></li><li><a class="tocitem" href="#Functions-from-file-LWFBrook90.jl"><span>Functions from file <code>LWFBrook90.jl</code></span></a></li><li><a class="tocitem" href="#Functions-from-files-func_read_inputData.jl,-func_discretize_soil_domain.jl,-or-func_postprocess.jl"><span>Functions from files <code>func_read_inputData.jl</code>, <code>func_discretize_soil_domain.jl</code>, or <code>func_postprocess.jl</code></span></a></li><li><a class="tocitem" href="#Functions-defining-the-DiffEq.jl-system-of-ODE-(p,-u0,-f,-callbacks,-...)"><span>Functions defining the DiffEq.jl system of ODE (p, u0, f, callbacks, ...)</span></a></li><li><a class="tocitem" href="#Functions-from-the-different-modules-defining-LWFBrook90"><span>Functions from the different modules defining LWFBrook90</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function Documentations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function Documentations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/fabern/LWFBrook90.jl/blob/develop/docs/src/function-docs.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Function-Documentations"><a class="docs-heading-anchor" href="#Function-Documentations">Function Documentations</a><a id="Function-Documentations-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Documentations" title="Permalink"></a></h1><h2 id="Functions-from-file-examples/BEA2016...-input/func_run_example.jl"><a class="docs-heading-anchor" href="#Functions-from-file-examples/BEA2016...-input/func_run_example.jl">Functions from file <code>examples/BEA2016...-input/func_run_example.jl</code></a><a id="Functions-from-file-examples/BEA2016...-input/func_run_example.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-from-file-examples/BEA2016...-input/func_run_example.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.run_example-Tuple{}" href="#LWFBrook90.run_example-Tuple{}"><code>LWFBrook90.run_example</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run_example()</code></pre><p>Run example simulation located in &quot;/examples/BEA2016-reset-FALSE-input&quot; for 100 days and return a Dict containing the solution (solution object of DifferentialEquations.jl) and other variables useful for plotting.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">using LWFBrook90
using Plots, Measures
example = LWFBrook90.run_example()

###
# A) Use in-built plotting function
optim_ticks = (x1, x2) -&gt; Plots.optimize_ticks(x1, x2; k_min = 4)
pl_inbuilt = LWFBrook90.ISO.plotisotopes(
    example[&quot;solution&quot;], optim_ticks;
    layout = grid(4, 1, heights=[0.1 ,0.4, 0.1, 0.4]),
    size=(1000,1400), dpi = 300, leftmargin = 15mm);
savefig(pl_inbuilt, &quot;Isotopeplots_pl_inbuilt.png&quot;)

###
# B) Construct plots yourself using the solution object
# Plot scalar solution
# Using simple plot recipe that interpolates, but without dates
plot(example[&quot;solution&quot;];
    vars = [1, 2, 3, 4, 5, 6],
    label=[&quot;GWAT (mm)&quot; &quot;INTS (mm)&quot; &quot;INTR (mm)&quot; &quot;SNOW (mm)&quot; &quot;CC (MJ/m2)&quot; &quot;SNOWLQ (mm)&quot;])

# Plot vector solution
x = example[&quot;solutionDates&quot;]
y = cumsum(example[&quot;thickness&quot;])
z = example[&quot;solution&quot;][7 .+ (0:example[&quot;NLAYER&quot;]-1), 1, :]./example[&quot;thickness&quot;]
heatmap(x, y, z,
    yflip = true,
    xlabel = &quot;Date&quot;,
    ylabel = &quot;Depth [mm]&quot;,
    colorbar_title = &quot;θ [-]&quot;)

# Plot both using plot recipe for LWFBrook90
using Plots, Measures
using LWFBrook90
optim_ticks = (x1, x2) -&gt; Plots.optimize_ticks(x1, x2; k_min = 4)

pl_final = LWFBrook90.plotlwfbrook90(sol_LWFBrook90, optim_ticks)
savefig(pl_final,
    input_prefix * &quot;_plotRecipe_NLAYER&quot; * string(sol_LWFBrook90.prob.p.p_soil.NLAYER) * &quot;.png&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/examples/func_run_example.jl#LL1-L48">source</a></section></article><h2 id="Functions-from-file-LWFBrook90.jl"><a class="docs-heading-anchor" href="#Functions-from-file-LWFBrook90.jl">Functions from file <code>LWFBrook90.jl</code></a><a id="Functions-from-file-LWFBrook90.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-from-file-LWFBrook90.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.DiscretizedSPAC" href="#LWFBrook90.DiscretizedSPAC"><code>LWFBrook90.DiscretizedSPAC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DiscretizedSPAC</code></pre><p>An discretization of a soil-plant-atmopsheric continuum model ready for simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/LWFBrook90.jl#LL83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.SPAC" href="#LWFBrook90.SPAC"><code>LWFBrook90.SPAC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SPAC</code></pre><p>An instance of a soil-plant-atmopsheric continuum model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/LWFBrook90.jl#LL28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.run_simulation-Tuple{Any}" href="#LWFBrook90.run_simulation-Tuple{Any}"><code>LWFBrook90.run_simulation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run_simulation(args)</code></pre><p>Runs a simulation defined by input files within a folder and returns solved DiscretizedSPAC.</p><p>The function run<em>simulation() takes as single argument a vector of two or three strings defining the input</em>path and input_prefix of a series of input definition files (and &quot;true&quot;/&quot;false&quot; whether to simulate isotopes). The function loads these files, runs the simulation and returns the solution object and input arguments</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/LWFBrook90.jl#LL440-L449">source</a></section></article><h2 id="Functions-from-files-func_read_inputData.jl,-func_discretize_soil_domain.jl,-or-func_postprocess.jl"><a class="docs-heading-anchor" href="#Functions-from-files-func_read_inputData.jl,-func_discretize_soil_domain.jl,-or-func_postprocess.jl">Functions from files <code>func_read_inputData.jl</code>, <code>func_discretize_soil_domain.jl</code>, or <code>func_postprocess.jl</code></a><a id="Functions-from-files-func_read_inputData.jl,-func_discretize_soil_domain.jl,-or-func_postprocess.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-from-files-func_read_inputData.jl,-func_discretize_soil_domain.jl,-or-func_postprocess.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.SPAC-Tuple{String, String}" href="#LWFBrook90.SPAC-Tuple{String, String}"><code>LWFBrook90.SPAC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SPAC(folder::String, prefix::String)</code></pre><p>Define instance of SPAC model by loading different input files for LWFBrook90:</p><ul><li><code>meteoveg.csv</code></li><li><code>param.csv</code></li><li><code>meteo_storm_durations.csv</code></li><li><code>initial_conditions.csv</code></li><li><code>soil_horizons.csv</code></li></ul><p>These files were created with an R script <code>generate_LWFBrook90jl_Input.R</code> that takes the same arguements as the R function <code>LWFBrook90R::run_LWFB90()</code> and generates the corresponding input files for LWFBrook90.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_read_inputData.jl#LL7-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.DateTime2RelativeDaysFloat-Tuple{Dates.DateTime, Dates.DateTime}" href="#LWFBrook90.DateTime2RelativeDaysFloat-Tuple{Dates.DateTime, Dates.DateTime}"><code>LWFBrook90.DateTime2RelativeDaysFloat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DateTime2RelativeDaysFloat(x,reference_DateTime)</code></pre><p>Transforms DateTimes <code>x</code> to simulation time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_read_inputData.jl#LL173-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.RelativeDaysFloat2DateTime-Tuple{Float64, Dates.DateTime}" href="#LWFBrook90.RelativeDaysFloat2DateTime-Tuple{Float64, Dates.DateTime}"><code>LWFBrook90.RelativeDaysFloat2DateTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RelativeDaysFloat2DateTime(t, reference_DateTime)</code></pre><p>Transforms simulation time <code>t</code> to DateTimes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_read_inputData.jl#LL182-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.p_DOY-Tuple{Float64, Dates.DateTime}" href="#LWFBrook90.p_DOY-Tuple{Float64, Dates.DateTime}"><code>LWFBrook90.p_DOY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">p_DOY(t::Float64, reference::DateTime)</code></pre><p>Get DOY (Day Of Year) from simulation time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_read_inputData.jl#LL192-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.p_MONTHN-Tuple{Float64, Dates.DateTime}" href="#LWFBrook90.p_MONTHN-Tuple{Float64, Dates.DateTime}"><code>LWFBrook90.p_MONTHN</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">p_MONTHN(t::Float64, reference::DateTime)</code></pre><p>Get Month from simulation time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_read_inputData.jl#LL200-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.read_path_param-Tuple{Any}" href="#LWFBrook90.read_path_param-Tuple{Any}"><code>LWFBrook90.read_path_param</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_path_param(path_param; simulate_isotopes::Bool = false)</code></pre><p>Reads in the <code>param.csv</code> based on a provided path. The <code>param.csv</code> has a structure shown in the documentation (User Guide -&gt; Input data). <a href="../user-guide/#Structure-of-input-data">Structure of input data</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_read_inputData.jl#LL535-L540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.HammelKennel_transient_root_density-Tuple{}" href="#LWFBrook90.HammelKennel_transient_root_density-Tuple{}"><code>LWFBrook90.HammelKennel_transient_root_density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HammelKennel_transient_root_density()</code></pre><p>Take root density distribution parameters and generates root density in time (t) and space (z, negative downward).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_discretize_soil_domain.jl#LL475-L479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.Rootden_beta_-Tuple{Any}" href="#LWFBrook90.Rootden_beta_-Tuple{Any}"><code>LWFBrook90.Rootden_beta_</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Rootden_beta_(
β;
Δz_m,
z_rootMax_m = maximum(cumsum(Δz_m)),
z_Upper_m = 0)</code></pre><p>Define the relative root density in each discretized soil layer based on the beta model from (Gale and Grigal, 1987).</p><p>This function returns the instantaneous root fraction (dY/dd) (units of -/cm). Unless cropped     by the total effective rooting depth the area under the curve sums up to 1.0 (when plotted vs cm).     The method reduces the amount of roots in a discretization layer in case the effective maximal rooting     depth comes to lie within that layer - it does not need to modify the discretization in that case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_discretize_soil_domain.jl#LL356-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.discretize_soil-Tuple{String}" href="#LWFBrook90.discretize_soil-Tuple{String}"><code>LWFBrook90.discretize_soil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">discretize_soil(folder::String, prefix::String; suffix::String = &quot;&quot;)</code></pre><p>Load input file <code>soil_discretization.csv</code> for LWFBrook90:</p><p>The file <code>soil_discretization.csv</code> was created with an R script <code>generate_LWFBrook90jl_Input.R</code> that takes the same arguements as the R function <code>LWFBrook90R::run_LWFB90()</code> and generates the corresponding input files for     LWFBrook90.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_discretize_soil_domain.jl#LL3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.discretize_soil-Union{Tuple{}, Tuple{T}} where T&lt;:Number" href="#LWFBrook90.discretize_soil-Union{Tuple{}, Tuple{T}} where T&lt;:Number"><code>LWFBrook90.discretize_soil</code></a> — <span class="docstring-category">Method</span></header><section><div><p>discretize<em>soil(;     Δz</em>m::Vector{T},     Rootden<em>::Function,     uAux</em>PSIM<em>init</em>kPa::Function,     u<em>delta18O</em>init<em>permil::Function = ((Δz</em>m) -&gt; missing),     u<em>delta2H</em>init<em>permil::Function = ((Δz</em>m) -&gt; missing))</p><p>Manually generate a soil- and root-discretization for LWFBrook90.jl. This function can be used as alternative to loading an input file <code>soil_discretization.csv</code>.</p><p>Reqired arguments are a vector with thickness of the discretization cells/layers in meter <code>Δ_m</code>, and functions <code>Rootden_(Δ_m)</code> that generates the root density, a function <code>uAux_PSIM_init_kPa(Δ_m)</code> that generates the initial values of ψ (kPa) for all cells as a function of <code>Δ_m</code>.</p><p>Optinal arguments are functions initial conditions of the two isotopic signatures based on <code>Δ_m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_discretize_soil_domain.jl#LL19-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.refine_soil_discretization-NTuple{5, Any}" href="#LWFBrook90.refine_soil_discretization-NTuple{5, Any}"><code>LWFBrook90.refine_soil_discretization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">refine_soil_discretization(
    input_soil_horizons,
    input_soil_discretization,
    soil_output_depths,
    IDEPTH_m,
    QDEPTH_m)</code></pre><p>Discretize soil domain into computational layers and attribute soil parameters based on the defined horizons. Densify discretization whenever an interface or an additional layer is needed. This is the case for interfaces when a new soil horizons begins or an additional computational layer (consisting of upper and lower interfaces) when a state variable needs to be extracted at a specified output depth.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_discretize_soil_domain.jl#LL77-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.get_K-Tuple{DiscretizedSPAC}" href="#LWFBrook90.get_K-Tuple{DiscretizedSPAC}"><code>LWFBrook90.get_K</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_K(simulation::DiscretizedSPAC; depths_to_read_out_mm = nothing, days_to_read_out_d = nothing)</code></pre><p>Returns a 2D matrix of soil hydraulic conductivities (mm/day) with soil layers as rows and time steps as columns. The user can define timesteps as <code>days_to_read_out_d</code> or specific depths as <code>depths_to_read_out_mm</code>, that are both optionally provided as numeric vectors, e.g. depths<em>to</em>read<em>out</em>mm = [100, 150] or saveat = 1:1.0:100</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_postprocess.jl#LL964-L970">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.get_SWATI-Tuple{DiscretizedSPAC}" href="#LWFBrook90.get_SWATI-Tuple{DiscretizedSPAC}"><code>LWFBrook90.get_SWATI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_SWATI(simulation::DiscretizedSPAC; depths_to_read_out_mm = nothing, days_to_read_out_d = nothing)</code></pre><p>Returns a 2D matrix of soil water volumes contained in discretized layers (mm) with soil layers as rows and time steps as columns. Note that the values depend on the thickness of the layers and thus on the discretization. The user can define timesteps as <code>days_to_read_out_d</code> or specific depths as <code>depths_to_read_out_mm</code>, that are both optionally provided as numeric vectors, e.g. depths<em>to</em>read<em>out</em>mm = [100, 150] or saveat = 1:1.0:100</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_postprocess.jl#LL941-L948">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.get_WETNES-Tuple{DiscretizedSPAC}" href="#LWFBrook90.get_WETNES-Tuple{DiscretizedSPAC}"><code>LWFBrook90.get_WETNES</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_WETNES(simulation::DiscretizedSPAC; depths_to_read_out_mm = nothing, days_to_read_out_d = nothing)</code></pre><p>Returns a 2D matrix of soil wetness (-) with soil layers as rows and time steps as columns. The user can define timesteps as <code>days_to_read_out_d</code> or specific depths as <code>depths_to_read_out_mm</code>, that are both optionally provided as numeric vectors, e.g. depths<em>to</em>read<em>out</em>mm = [100, 150] or saveat = 1:1.0:100</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_postprocess.jl#LL919-L925">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.get_aboveground-Tuple{DiscretizedSPAC}" href="#LWFBrook90.get_aboveground-Tuple{DiscretizedSPAC}"><code>LWFBrook90.get_aboveground</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_aboveground(simulation::DiscretizedSPAC; days_to_read_out_d = nothing)</code></pre><p>Returns a DataFrame with state variables: GWAT, INTS, INTR, SNOW, SNOWLQ in mm and CC in MJm2. By default, the values are returned for each simulation timestep. The user can define timesteps as <code>days_to_read_out_d</code> by optionally providing a numeric vector, e.g. saveat = 1:1.0:100</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_postprocess.jl#LL1023-L1029">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.get_δ-Tuple{DiscretizedSPAC}" href="#LWFBrook90.get_δ-Tuple{DiscretizedSPAC}"><code>LWFBrook90.get_δ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_δ(simulation::DiscretizedSPAC; days_to_read_out_d = nothing)</code></pre><p>Returns a DataFrame with the isotopoic compositions of the inputs and state variables: PREC, GWAT, INTS, INTR, SNOW, RWU, XYLEM. By default, the values are returned for each simulation timestep. The user can define timesteps as <code>days_to_read_out_d</code> by optionally providing a numeric vector, e.g. saveat = 1:1.0:100</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_postprocess.jl#LL1053-L1059">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.get_δsoil-Tuple{DiscretizedSPAC}" href="#LWFBrook90.get_δsoil-Tuple{DiscretizedSPAC}"><code>LWFBrook90.get_δsoil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_δsoil(simulation::DiscretizedSPAC; depths_to_read_out_mm = nothing, days_to_read_out_d = nothing)</code></pre><p>Returns tuple of two 2D matrices of isotopic signatures of soil water (δ in permil) for d18O and d2H. The 2D matrix with soil layers as rows and time steps as columns can be accessed with <code>.d18O</code> and <code>.d2H</code>, respectively. The user can define timesteps as <code>days_to_read_out_d</code> or specific depths as <code>depths_to_read_out_mm</code>, that are both optionally provided as numeric vectors, e.g. depths<em>to</em>read<em>out</em>mm = [100, 150] or saveat = 1:1.0:100</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_postprocess.jl#LL987-L994">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.get_θ-Tuple{DiscretizedSPAC}" href="#LWFBrook90.get_θ-Tuple{DiscretizedSPAC}"><code>LWFBrook90.get_θ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_θ(simulation::DiscretizedSPAC; depths_to_read_out_mm = nothing, days_to_read_out_d = nothing)</code></pre><p>Returns a 2D matrix of volumetric soil moisture values (m3/m3) with soil layers as rows and time steps as columns. The user can define timesteps as <code>days_to_read_out_d</code> or specific depths as <code>depths_to_read_out_mm</code>, that are both optionally provided as numeric vectors, e.g. depths<em>to</em>read<em>out</em>mm = [100, 150] or saveat = 1:1.0:100</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_postprocess.jl#LL875-L881">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.get_ψ-Tuple{DiscretizedSPAC}" href="#LWFBrook90.get_ψ-Tuple{DiscretizedSPAC}"><code>LWFBrook90.get_ψ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_ψ(simulation::DiscretizedSPAC; depths_to_read_out_mm = nothing, days_to_read_out_d = nothing)</code></pre><p>Returns a 2D matrix of soil matric potential (kPa) with soil layers as rows and time steps as columns. The user can define timesteps as <code>days_to_read_out_d</code> or specific depths as <code>depths_to_read_out_mm</code>, that are both optionally provided as numeric vectors, e.g. depths<em>to</em>read<em>out</em>mm = [100, 150] or saveat = 1:1.0:100</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_postprocess.jl#LL897-L903">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.plotamounts!-Tuple" href="#LWFBrook90.plotamounts!-Tuple"><code>LWFBrook90.plotamounts!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plotamounts(simulation::DiscretizedSPAC)
plotamounts(simulation::DiscretizedSPAC, compartments::Symbol)
plotamounts(simulation::DiscretizedSPAC, compartments::Symbol, RWUcentroid::Symbol)</code></pre><p>Plots the amount results of a SPAC Simulation. By default both above and belowground. The user can override this with the second argument isotope as one of <code>:aboveground</code>, <code>:belowground</code>, or <code>:above_and_belowground</code>. RWUcentroid can have values of either :dontShowRWUcentroid or :showRWUcentroid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_postprocess.jl#LL1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.plotamounts!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}" href="#LWFBrook90.plotamounts!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}"><code>LWFBrook90.plotamounts!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plotamounts(simulation::DiscretizedSPAC)
plotamounts(simulation::DiscretizedSPAC, compartments::Symbol)
plotamounts(simulation::DiscretizedSPAC, compartments::Symbol, RWUcentroid::Symbol)</code></pre><p>Plots the amount results of a SPAC Simulation. By default both above and belowground. The user can override this with the second argument isotope as one of <code>:aboveground</code>, <code>:belowground</code>, or <code>:above_and_belowground</code>. RWUcentroid can have values of either :dontShowRWUcentroid or :showRWUcentroid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_postprocess.jl#LL1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.plotamounts-Tuple" href="#LWFBrook90.plotamounts-Tuple"><code>LWFBrook90.plotamounts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plotamounts(simulation::DiscretizedSPAC)
plotamounts(simulation::DiscretizedSPAC, compartments::Symbol)
plotamounts(simulation::DiscretizedSPAC, compartments::Symbol, RWUcentroid::Symbol)</code></pre><p>Plots the amount results of a SPAC Simulation. By default both above and belowground. The user can override this with the second argument isotope as one of <code>:aboveground</code>, <code>:belowground</code>, or <code>:above_and_belowground</code>. RWUcentroid can have values of either :dontShowRWUcentroid or :showRWUcentroid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_postprocess.jl#LL1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.plotforcingandstates!-Tuple" href="#LWFBrook90.plotforcingandstates!-Tuple"><code>LWFBrook90.plotforcingandstates!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plotforcingandstates(simulation::DiscretizedSPAC)</code></pre><p>Plots the forcing, states and major fluxes as results of a SPAC Simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_postprocess.jl#LL636-L640">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.plotforcingandstates!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}" href="#LWFBrook90.plotforcingandstates!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}"><code>LWFBrook90.plotforcingandstates!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plotforcingandstates(simulation::DiscretizedSPAC)</code></pre><p>Plots the forcing, states and major fluxes as results of a SPAC Simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_postprocess.jl#LL636-L640">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.plotforcingandstates-Tuple" href="#LWFBrook90.plotforcingandstates-Tuple"><code>LWFBrook90.plotforcingandstates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plotforcingandstates(simulation::DiscretizedSPAC)</code></pre><p>Plots the forcing, states and major fluxes as results of a SPAC Simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_postprocess.jl#LL636-L640">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.plotisotopes!-Tuple" href="#LWFBrook90.plotisotopes!-Tuple"><code>LWFBrook90.plotisotopes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plotisotopes(simulation::DiscretizedSPAC)
plotisotopes(simulation::DiscretizedSPAC, isotope::Symbol)
plotisotopes(simulation::DiscretizedSPAC, isotope::Symbol, RWUcentroid::Symbol)</code></pre><p>Plots the isotope results of a SPAC Simulation. By default both δ18O and δ2H. The user can override this with the second argument isotope as one of <code>:d18O</code>, <code>:d2H</code>, or <code>:d18O_and_d2H</code>. RWUcentroid can have values of either :dontShowRWUcentroid or :showRWUcentroid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_postprocess.jl#LL356-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.plotisotopes!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}" href="#LWFBrook90.plotisotopes!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}"><code>LWFBrook90.plotisotopes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plotisotopes(simulation::DiscretizedSPAC)
plotisotopes(simulation::DiscretizedSPAC, isotope::Symbol)
plotisotopes(simulation::DiscretizedSPAC, isotope::Symbol, RWUcentroid::Symbol)</code></pre><p>Plots the isotope results of a SPAC Simulation. By default both δ18O and δ2H. The user can override this with the second argument isotope as one of <code>:d18O</code>, <code>:d2H</code>, or <code>:d18O_and_d2H</code>. RWUcentroid can have values of either :dontShowRWUcentroid or :showRWUcentroid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_postprocess.jl#LL356-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.plotisotopes-Tuple" href="#LWFBrook90.plotisotopes-Tuple"><code>LWFBrook90.plotisotopes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plotisotopes(simulation::DiscretizedSPAC)
plotisotopes(simulation::DiscretizedSPAC, isotope::Symbol)
plotisotopes(simulation::DiscretizedSPAC, isotope::Symbol, RWUcentroid::Symbol)</code></pre><p>Plots the isotope results of a SPAC Simulation. By default both δ18O and δ2H. The user can override this with the second argument isotope as one of <code>:d18O</code>, <code>:d2H</code>, or <code>:d18O_and_d2H</code>. RWUcentroid can have values of either :dontShowRWUcentroid or :showRWUcentroid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_postprocess.jl#LL356-L364">source</a></section></article><h2 id="Functions-defining-the-DiffEq.jl-system-of-ODE-(p,-u0,-f,-callbacks,-...)"><a class="docs-heading-anchor" href="#Functions-defining-the-DiffEq.jl-system-of-ODE-(p,-u0,-f,-callbacks,-...)">Functions defining the DiffEq.jl system of ODE (p, u0, f, callbacks, ...)</a><a id="Functions-defining-the-DiffEq.jl-system-of-ODE-(p,-u0,-f,-callbacks,-...)-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-defining-the-DiffEq.jl-system-of-ODE-(p,-u0,-f,-callbacks,-...)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.define_LWFB90_u0-Tuple{}" href="#LWFBrook90.define_LWFB90_u0-Tuple{}"><code>LWFBrook90.define_LWFB90_u0</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">define_LWFB90_u0()</code></pre><p>Generate vector u0 needed for ODE() problem in DiffEq.jl package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_DiffEq_definition_u0.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.HammelKennel_lateral_rootgrowth-Tuple{}" href="#LWFBrook90.HammelKennel_lateral_rootgrowth-Tuple{}"><code>LWFBrook90.HammelKennel_lateral_rootgrowth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HammelKennel_lateral_rootgrowth(;final_relden, tini_yrs, INITRDEP_m, INITRLEN_m_per_m2, RGROPER_yrs, age_yrs)</code></pre><p>Compute root growth according to LWF Bayern root growth model, (Hammel and Kennel 2000).</p><p><strong>Arguments:</strong></p><pre><code class="nohighlight hljs">- `final_relden[i]`  :  final relative values of root length per unit volume in a specific layer i
- `INITRDEP_m`       :  intial root depth, m
- `INITRLEN_m_per_m2`:  initial water-absorbing root length per unit area, m m-2
- `t_y`              :  current age of vegetation, yrs
- `tstart_y[i]`      :  initial age for root growth in a specific layer i, yrs
- `RGROPER_yrs`      :  period of root growth in layer, yrs</code></pre><p>Returns:     - <code>RELDEN[]</code>         : current, age-dependent relative values of root length per unit volume</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_DiffEq_definition_p.jl#LL602-L616">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.define_LWFB90_p-Tuple{SPAC, Any, Any}" href="#LWFBrook90.define_LWFB90_p-Tuple{SPAC, Any, Any}"><code>LWFBrook90.define_LWFB90_p</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">define_diff_eq_parameters()</code></pre><p>Generate vector p needed for ODE() problem in DiffEq.jl package.</p><p><strong>Arguments</strong></p><ul><li><code>continuous_SPAC::SPAC</code>: Instance of a SPAC-model (soil-plant-atmosphere continuum)</li><li><code>compute_intermediate_quantities::...</code>: TODO argument description.</li><li><code>simulate_isotopes::...</code>: TODO argument description.</li><li><code>soil_output_depths</code>: vector of depths at which state variables should be extractable (negative numeric values [in meter])</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_DiffEq_definition_p.jl#LL2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.interpolate_meteoveg-Tuple{}" href="#LWFBrook90.interpolate_meteoveg-Tuple{}"><code>LWFBrook90.interpolate_meteoveg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpolate_meteoveg(
    input_meteoveg::DataFrame,
    input_meteoveg_reference_date::DateTime,
    input_meteoiso::DataFrame, )</code></pre><p>Take climate and vegetation parameters in <code>input_meteoveg</code> and <code>input_meteoiso</code> and generates continuous parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_DiffEq_definition_p.jl#LL641-L648">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.solve_LWFB90-Tuple{Any, Any, Any}" href="#LWFBrook90.solve_LWFB90-Tuple{Any, Any, Any}"><code>LWFBrook90.solve_LWFB90</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve_LWFB90(u0, tspan, p)</code></pre><p>Generates an ODEProblem from DiffEq.jl and solves it over period tspan using initial conditions u0. RHS f() and callbacks cb() are defined internally to LWFBrook90.jl</p><p>An ODE problem which consists of     - definition of right-hand-side (RHS) function f     - definition of callback function cb     - initial condition of states     - definition of simulation time span     - parameters</p><p>Seperate updating of different states (INTS, INTR, SNOW, CC, SNOWLQ are updated once per day while GWAT and SWATI are updated continuously) is implemented by means of operator splitting using a callback function for the daily updates and a ODE RHS (right hand side) for the continuous update.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_DiffEq_definition_ode.jl#LL1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.MSBDAYNIGHT-NTuple{47, Any}" href="#LWFBrook90.MSBDAYNIGHT-NTuple{47, Any}"><code>LWFBrook90.MSBDAYNIGHT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MSBDAYNIGHT()</code></pre><p>Calculate average daily rate of potential and actual interception, evaporation, and transpiration by considering weighted average of rate during day and rate during night: Subroutine MSBDAYNIGHT - day-night loop: Compute day and night rates</p><p><strong>Arguments</strong></p><ul><li>many</li></ul><p>http://www.ecoshift.net/brook/pet.html</p><p>BROOK90 obtains evaporation rates separately for daytime and nighttime within a day-night evaporation loop. All solar radiation (SOLRAD) is assigned to the daytime. The atmospheric humidity (EA) is assumed constant through the day (&quot;day&quot; refers to 24 hours). The daytime and nighttime values of air temperature and wind speed are obtained in subroutine WEATHER using function WNDADJ. Vapor pressure deficit (VPD) is obtained using subroutine ESAT. Subroutine CANOPY uses function INTERP to obtain canopy structure variables for the day. Subroutine ROUGH gets canopy roughness parameters. Within a day-night loop, the three aerodynamic resistances needed by the Shuttleworth-Wallace method are calculated in subroutine SWGRA. The canopy surface resistance (RSC) for the daytime is obtained from subroutine SRSC, and the soil surface resistance (RSS) in function FRSS. Subroutine SWPE uses function PM along with the various resistances to obtain potential transpiration rate (PTR) and the associated ground or soil evaporation rate (GER) by the Shuttleworth-Wallace equations. Subroutine SWPE is called again with RSC = 0 to give potential interception rate (PIR) and its associated soil evaporation rate (GIR). Subroutine TBYLAYER obtains actual transpiration by layer (ATRANI). If the actual transpiration is less than the potential, a new, higher GER is calculated by subroutine SWGE. BROOK90 then weights the daytime and nighttime rates by the solar daylength (DAYLEN) to obtain average rates for the day, PTRAN, GEVP, PINT, GIVP, and TRANI, which are used in later calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_MSB_functions.jl#LL102-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.MSBDAYNIGHT_postprocess-NTuple{7, Any}" href="#LWFBrook90.MSBDAYNIGHT_postprocess-NTuple{7, Any}"><code>LWFBrook90.MSBDAYNIGHT_postprocess</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MSBDAYNIGHT_postprocess()</code></pre><p>Calculate average daily rate of potential and actual interception, evaporation, and transpiration by considering weighted average of rate during day and rate during night: Subroutine MSBDAYNIGHT_postprocess - Combine day and night rates to average daily rate</p><p><strong>Arguments</strong></p><ul><li>many</li></ul><p>http://www.ecoshift.net/brook/pet.html</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_MSB_functions.jl#LL246-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.MSBSETVARS-NTuple{52, Any}" href="#LWFBrook90.MSBSETVARS-NTuple{52, Any}"><code>LWFBrook90.MSBSETVARS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MSBSETVARS()</code></pre><p>Compute state dependent parameters for updating states INTS, INTR, SNOW, CC, SNOWLQ in callback function.</p><p><strong>Arguments</strong></p><ul><li>many</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_MSB_functions.jl#LL2-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.compute_isotope_U_of_INTS_INTR_SNOW_and_SLFL-NTuple{24, Any}" href="#LWFBrook90.compute_isotope_U_of_INTS_INTR_SNOW_and_SLFL-NTuple{24, Any}"><code>LWFBrook90.compute_isotope_U_of_INTS_INTR_SNOW_and_SLFL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_isotope_U_of_INTS_INTR_SNOW_and_SLFL(
    p_δ2H_PREC, p_δ18O_PREC, p_fT_TADTM, p_fT_VAPPRES,
    # for INTS (in: SINT; out: ISVP):
    u_INTS, aux_du_SINT, aux_du_ISVP, p_DTP, u_δ2H_INTS, u_δ18O_INTS,
    # for INTR (in: RINT; out: IRVP):
    u_INTR, aux_du_RINT, aux_du_IRVP, u_δ2H_INTR, u_δ18O_INTR,
    # for SNOW (in: STHR, RSNO (both δ_PREC); out: SMLT, SNVP (δ_SNOW and fractionated)):
    p_fu_STHR, aux_du_RSNO, aux_du_SMLT, aux_du_SNVP, u_δ2H_SNOW, u_δ18O_SNOW,
    # to compute isotopic signature of soil infiltration: SLFL
    p_fu_RNET)</code></pre><p>Computes updated values of states INTS, INTR, and SNOW as well as their isotopic composition. Compute mixing and evaporative fractionation, and also compute the isotopic composotion of the resulting flux that infiltrates into the soil: p<em>fu</em>δ18O<em>SLFL, p</em>fu<em>δ2H</em>SLFL</p><p>The function is called in the daily callback.</p><p>The function returns: p<em>fu</em>δ18O<em>SLFL, p</em>fu<em>δ2H</em>SLFL, as well as:     u<em>INTS     u</em>δ18O<em>INTS     u</em>δ2H<em>INTS     u</em>INTR     u<em>δ18O</em>INTR     u<em>δ2H</em>INTR     u<em>SNOW     u</em>δ18O<em>SNOW     u</em>δ2H_SNOW</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_MSB_functions.jl#LL511-L539">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.compute_isotope_du_GWAT_SWATI-NTuple{21, Any}" href="#LWFBrook90.compute_isotope_du_GWAT_SWATI-NTuple{21, Any}"><code>LWFBrook90.compute_isotope_du_GWAT_SWATI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_isotope_du_GWAT_SWATI(
    # for GWAT:
    u_GWAT, u_δ18O_GWAT, u_δ2H_GWAT,
    # for SWATI:
    du_NTFLI, aux_du_VRFLI, aux_du_TRANI, aux_du_DSFLI, aux_du_INFLI, δ18O_INFLI, δ2H_INFLI, # (non-fractionating)
    aux_du_SLVP, p_fT_TADTM, p_fT_VAPPRES, p_δ2H_PREC, p_δ18O_PREC, u_aux_WETNES, # (fractionating)
    u_SWATI, u_δ18O_SWATI, u_δ2H_SWATI, EffectiveDiffusivity_18O, EffectiveDiffusivity_2H,
    )</code></pre><p>Computes rate of change (du) of isotopic composition of states: δ18O<em>GWAT, δ2H</em>GWAT, δ18O<em>SWATI, δ2H</em>SWATI By computing the rates of change this function is needed when we track the isotopic composition by numerically solving an ODE. Alternatively we can use a callback and updated the isotopic compositions separately from solving the flow equation (by using <code>compute_isotope_u_GWAT_SWATI</code>).</p><p>The function returns: du<em>δ18O</em>GWAT, du<em>δ2H</em>GWAT, du<em>δ18O</em>SWATI, du<em>δ2H</em>SWATI that can be used for numerically solving the evolution of state (either in function f or in cb by using a simple time stepping algorithm).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_MSB_functions.jl#LL731-L750">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.compute_isotope_u_GWAT_SWATI-NTuple{24, Any}" href="#LWFBrook90.compute_isotope_u_GWAT_SWATI-NTuple{24, Any}"><code>LWFBrook90.compute_isotope_u_GWAT_SWATI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_isotope_u_GWAT_SWATI(integrator,
    # for GWAT:
    u_GWAT, u_δ18O_GWAT, u_δ2H_GWAT, du_GWFL, du_SEEP,
    # for SWATI:
    du_NTFLI, aux_du_VRFLI, aux_du_TRANI, aux_du_DSFLI, aux_du_INFLI, δ18O_INFLI, δ2H_INFLI, # (non-fractionating)
    aux_du_SLVP, p_fT_TADTM, p_fT_VAPPRES, p_δ2H_PREC, p_δ18O_PREC, u_aux_WETNES, # (fractionating)
    u_SWATI, u_δ18O_SWATI, u_δ2H_SWATI, EffectiveDiffusivity_18O, EffectiveDiffusivity_2H,
    )</code></pre><p>Computes new states of isotopic composition of GWAT and SWATI by using an operator splitting approach between the non-fractionating fluxes (mixing) and fractionating fluxes (evaporation) in the water balance. This allows to use analytical solutions by considering the effects to be separated. It computes first an auxiliary state vector after all the mixing fluxes are considered and then for each water pool evolution of the isotopic composition due to fractionating fluxes is considered by assuming the fractionating flux is the only outgoing flux during the entire time step.</p><p>When no operator splitting is desired, the user could use the numerical approach that considers all of the fluxes to modify the isotopic compositions simultaneously. This is done by using the alternative function <code>compute_isotope_du_GWAT_SWATI()</code></p><p>The function returns: u<em>δ18O</em>GWAT, u<em>δ2H</em>GWAT, u<em>δ18O</em>SWATI, u<em>δ2H</em>SWATI</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/func_MSB_functions.jl#LL770-L793">source</a></section></article><h2 id="Functions-from-the-different-modules-defining-LWFBrook90"><a class="docs-heading-anchor" href="#Functions-from-the-different-modules-defining-LWFBrook90">Functions from the different modules defining LWFBrook90</a><a id="Functions-from-the-different-modules-defining-LWFBrook90-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-from-the-different-modules-defining-LWFBrook90" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.KPT.AbstractSoilHydraulicParams" href="#LWFBrook90.KPT.AbstractSoilHydraulicParams"><code>LWFBrook90.KPT.AbstractSoilHydraulicParams</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSoilHydraulicParams</code></pre><p>Represents an abstract parametrization of soil hydraulics. Examples of soil hydraulic parametrizations are:</p><ul><li>Mualem-van Genuchten</li><li>Clapp-Hornberger</li></ul><p>A summary is available in Shao, Y. and Irannejad, P.: On the Choice of Soil Hydraulic Models in Land-Surface Schemes, Boundary Layer Meterol., 90, 83–115, https://doi.org/10.1023/A:1001786023282, 1999.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_KPT.jl#LL107-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.KPT.ClappHornbergerSHP" href="#LWFBrook90.KPT.ClappHornbergerSHP"><code>LWFBrook90.KPT.ClappHornbergerSHP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ClappHornbergerSHP</code></pre><p>Clapp-Hornberger parametrization of soil hydraulics</p><p class="math-container">\[\frac{\psi}{\psi_s} = w^{-1/\lambda} \qquad \textup{if: }\psi \leq \psi_i \\
\psi                = -m(w-n)(w-1) \qquad \textup{if: }\psi_i \leq \psi \leq 0 \\
K(\theta)           = K_s \left( \frac{\theta}{\theta_s} \right)^{(3+2/\lambda)} \\
\\
\textup{Parameters:} \\
m = \frac{\psi_i}{(1-w_i)^2} - \frac{\psi_i}{w_i(1-w_i)\lambda} \\
n = 2w_i - \frac{\psi_i}{mw_i\lambda} -1\]</p><p>source: Shao, Y. and Irannejad, P.: On the Choice of Soil Hydraulic Models in Land-Surface Schemes, Boundary Layer Meterol., 90, 83–115, https://doi.org/10.1023/A:1001786023282, 1999.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_KPT.jl#LL173-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.KPT.KPT_SOILPAR_Ch1d" href="#LWFBrook90.KPT.KPT_SOILPAR_Ch1d"><code>LWFBrook90.KPT.KPT_SOILPAR_Ch1d</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represents a discretized 1D column of soil with Clapp-Hornberger parametrization.</p><p>Input fields: p<em>THICK, p</em>STONEF, p<em>THSAT, p</em>PSIF, p<em>THETAF, p</em>KF, p<em>BEXP, p</em>WETINF Derived fields: NLAYER, p<em>CHM, p</em>CHN, p<em>THETAF, p</em>PSIG, p<em>SWATMAX, p</em>WETF, p_PsiCrit</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_KPT.jl#LL209-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.KPT.KPT_SOILPAR_Mvg1d" href="#LWFBrook90.KPT.KPT_SOILPAR_Mvg1d"><code>LWFBrook90.KPT.KPT_SOILPAR_Mvg1d</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represents a discretized 1D column of soil with Mualem-van Genuchten parametrization.</p><p>Input fields: p<em>THICK, p</em>STONEF, p<em>THSAT, p</em>Kθfc, p<em>KSAT, p</em>MvGα, p<em>MvGn, p</em>MvGl, p<em>θr Derived fields: p</em>PSIF, p<em>THETAF, p</em>PSIG, p<em>SWATMAX, p</em>WETF, p_PsiCrit</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_KPT.jl#LL290-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.KPT.MualemVanGenuchtenSHP" href="#LWFBrook90.KPT.MualemVanGenuchtenSHP"><code>LWFBrook90.KPT.MualemVanGenuchtenSHP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MualemVanGenuchtenSHP</code></pre><p>Mualem-van Genuchten parametrization of soil hydraulics</p><p class="math-container">\[\Theta    = \frac{\theta - \theta_r}{\theta_s - \theta_r} = \left( \frac{1}{1+(-\alpha \psi)^n} \right)^m \\
n         = \frac{1}{m-1} \\
K(\theta) = K_s \Theta^{1/2}\left[ 1 - (1 - \Theta^{1/m})^m \right ]^2 \\
K(\psi)   = K_s\frac{\left[ 1- (-\alpha\psi)^{n-1} (1 + (-\alpha \psi)^n)^{-m} \right ]^2}{\left[ 1 + (-\alpha\psi)^n \right ]^{m/2}}\]</p><p>source: Shao, Y. and Irannejad, P.: On the Choice of Soil Hydraulic Models in Land-Surface Schemes, Boundary Layer Meterol., 90, 83–115, https://doi.org/10.1023/A:1001786023282, 1999.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_KPT.jl#LL120-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.KPT.FDPSIDWF-Tuple{Any, LWFBrook90.KPT.KPT_SOILPAR_Ch1d}" href="#LWFBrook90.KPT.FDPSIDWF-Tuple{Any, LWFBrook90.KPT.KPT_SOILPAR_Ch1d}"><code>LWFBrook90.KPT.FDPSIDWF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FDPSIDWF_CH(u_aux_WETNES, p_soil)</code></pre><p>Compute derivative dψi/dWi for each layer i.</p><p>Ecoshift: FDPSIDW returns dψi/dWi for one layer, which is needed for the selection of iteration time-step.</p><p>For Clapp-Hornberger: Differentiation of (7) and (4) leads to dψi / dWi = ( -b ψf / Wf ) ( Wi / Wf )-b-1 in the unsaturated range, dψi / dWi= m ( 2 Wi - n - 1 ) in the near saturation range, and dψi / dWi = 0 when the soil is saturated (Wi = 1).</p><p>For Mualem-van Genuchten: dψi / dWi = TODO.... write documentation here</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_KPT.jl#LL541-L561">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.KPT.FK_MvG-NTuple{4, Any}" href="#LWFBrook90.KPT.FK_MvG-NTuple{4, Any}"><code>LWFBrook90.KPT.FK_MvG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FK_MvG(WETNES, KSAT, MvGl, MvGn)</code></pre><p>Compute hydraulic conductivity from wetness for the Mualem van Genuchten parametrization.</p><p>Compute unsaturated hydraulic conductivity: K(Se) a.k.a. K(W) using MvG equation 8) K = Ks<em>W^l</em>[ 1 - (1-W^(1/m))^m ]^2 using m = 1-1/n yields: K = Ks<em>W^l</em>[ 1 - (1-W^(n/(n-1)))^(1-1/n) ]^2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_KPT.jl#LL463-L471">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.KPT.FPSIM-Tuple{Any, LWFBrook90.KPT.KPT_SOILPAR_Ch1d}" href="#LWFBrook90.KPT.FPSIM-Tuple{Any, LWFBrook90.KPT.KPT_SOILPAR_Ch1d}"><code>LWFBrook90.KPT.FPSIM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FPSIM(u_aux_WETNES, p_soil)</code></pre><p>Compute ψ(Se) = h(Se) a.k.a ψ(W) = h(W).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_KPT.jl#LL480-L484">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.KPT.FTheta-Tuple{Any, LWFBrook90.KPT.KPT_SOILPAR_Mvg1d}" href="#LWFBrook90.KPT.FTheta-Tuple{Any, LWFBrook90.KPT.KPT_SOILPAR_Mvg1d}"><code>LWFBrook90.KPT.FTheta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FTheta(u_aux_WETNES, p_soil)</code></pre><p>Compute θ based on Se.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_KPT.jl#LL611-L615">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.KPT.FWETNES-Tuple{Any, LWFBrook90.KPT.KPT_SOILPAR_Mvg1d}" href="#LWFBrook90.KPT.FWETNES-Tuple{Any, LWFBrook90.KPT.KPT_SOILPAR_Mvg1d}"><code>LWFBrook90.KPT.FWETNES</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FWETNES(u_aux_PSIM, p_soil)</code></pre><p>Computes θ(ψ) = θ(h) by computing first Se(ψ)=Se(h) a.k.a  W(ψ)=W(h)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_KPT.jl#LL633-L637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.KPT.SWCHEK!-Tuple{Any, Any, Any}" href="#LWFBrook90.KPT.SWCHEK!-Tuple{Any, Any, Any}"><code>LWFBrook90.KPT.SWCHEK!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SWCHEK(u_SWATI)</code></pre><p>Correct u_SWATI and throw error if too far away.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_KPT.jl#LL687-L691">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.KPT.derive_auxiliary_SOILVAR-Tuple{Any, LWFBrook90.KPT.KPT_SOILPAR_Mvg1d}" href="#LWFBrook90.KPT.derive_auxiliary_SOILVAR-Tuple{Any, LWFBrook90.KPT.KPT_SOILPAR_Mvg1d}"><code>LWFBrook90.KPT.derive_auxiliary_SOILVAR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">derive_auxiliary_SOILVAR(u_SWATI, p_soil)</code></pre><p>Derive alternative representations of soil water status.</p><p>Based on the state <code>u_SWATI</code> it returns (<code>u_aux_WETNES</code>, <code>u_aux_PSIM</code>, <code>u_aux_PSITI</code>, <code>p_fu_KK</code>)</p><ul><li><code>u_aux_WETNES</code>: wetness, fraction of saturation</li><li><code>u_aux_PSIM</code>:   matric soil water potential for layer, kPa</li><li><code>p_PSIG</code>:       gravity potential, kPa</li><li><code>u_aux_PSITI</code>:  total potential ψt = ψm + ψg (sum of matrix potential and gravity potential)</li><li><code>u_aux_θ</code>:      volumetric soil water content, m3/m3</li><li><code>p_fu_KK</code>:      unsaturated hydraulic conductivity: K(Se) a.k.a. K(W)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_KPT.jl#LL401-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.WAT.BYFLFR-NTuple{6, Any}" href="#LWFBrook90.WAT.BYFLFR-NTuple{6, Any}"><code>LWFBrook90.WAT.BYFLFR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BYFLFR(NLAYER, p_BYPAR, p_QFPAR, p_QFFC, u_aux_WETNES, p_WETF)</code></pre><p>Compute fraction of bypass flow.</p><p><strong>Ecoshift</strong></p><p>&quot; Bypass flow (BYFL) and surface or source area flow (SRFL) are the two stormflow or quickflow generating mechanisms in BROOK90. The conceptual difference is that SRFL is &quot;new&quot; water that has not infiltrated but has moved across the surface to a channel, whereas BYFL is &quot;new&quot; water that has moved to a channel below the surface via macropores or pipes. In BROOK90 the amount of BYFL from each layer depends on the wetness of that particular layer and on the amount of infiltration to it, which is controlled by INFEXP. The amount of SRFL depends on the total wetness of all soil layers down to and including input parameter QDEPTH<em>m . In general users should not try to model BYFL and SRFL simultaneously because trying to fit parameters for both at the same time would be too complicated. The parameter BYPAR is set to 1 to allow BYFL and zero to prevent it. SRFL is prevented by setting both QDEPTH</em>m and IMPERV to zero. The same parameters, QFFC and QFPAR, are used for SRFL and for BYFL from all layers.</p><p>When BYPAR = 0, there is no bypass flow from deeper layers, but bypass flow is still generated from layer 1 when the layer would otherwise become oversaturated. When INFEXP = 0 or IDEPTH_m = 0, BYFL can only be generated from layer 1 because it is the only layer receiving infiltrated water.</p><p>In each iteration loop, subroutine BYFLFR calculates the fraction of the water infiltrating to each layer that becomes bypass flow (BYFRACi) as</p><p>BYFRACi = QFFC ^ [ 1 - (1 / QFPAR) * (WETNESi - WETFi) / (1 - WETFi ) ]</p><p>where WETNESi is the layer wetness, WETFi is the layer wetness at field capacity, and QFFC and QFPAR are parameters. QFFC is the bypass fraction at field capacity (WETNESi = WETFi). QFPAR represents the fraction of the water content between field capacity and saturation at which BYFRAC reaches 1 (Fig. WAT-2). BYFRAC increases exponentially with layer wetness and is prevented from exceeding 1. Raising QFFC will raise BYFL proportionally at all water contents. Raising QFPAR will increase BYFL for soil drier than field capacity and decrease it for soil above field capacity (Fig. WAT-2).</p><p>With BYPAR = 1 and QFPAR = 0, BYFRAC is 0 below field capacity and 1 above it, and QFFC is ignored. With a single soil layer and no SRFL, this produces a classic &quot;bucket&quot; model, with the leakiness of the bucket determined by DRAIN. With multiple layers and BYPAR = 1, the bucket model does not work because a layer at field capacity diverts all excess water to BYFL, preventing wetting of deeper layers. See SRFLFR for a modified bucket model with multiple layers.</p><p>When QFPAR = 1, BYFRAC reaches 1 when the layer is saturated (Fig WAT-2). A very large QFPAR produces a constant BYFRAC of QFFC.</p><p>Note that BYFRAC is calculated from soil water prior to the input of water for the time step. &quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_WAT.jl#LL82-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.WAT.DSLOP-NTuple{6, Any}" href="#LWFBrook90.WAT.DSLOP-NTuple{6, Any}"><code>LWFBrook90.WAT.DSLOP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DSLOP()</code></pre><p>Compute downslope flow rate from layer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_WAT.jl#LL181-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.WAT.GWATER-NTuple{4, Any}" href="#LWFBrook90.WAT.GWATER-NTuple{4, Any}"><code>LWFBrook90.WAT.GWATER</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GWATER(u_GWAT, p_GSC, p_GSP, aux_du_VRFLIN)</code></pre><p>Calculate groundwater flow and seepage loss.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_WAT.jl#LL619-L623">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.WAT.INFLOW-NTuple{11, Any}" href="#LWFBrook90.WAT.INFLOW-NTuple{11, Any}"><code>LWFBrook90.WAT.INFLOW</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">INFLOW(NLAYER, DTI, p_INFRAC, p_fu_BYFRAC, p_fu_SLFL,
aux_du_DSFLI, aux_du_TRANI, aux_du_SLVP, p_SWATMAX, u_SWATI, VRFLI_prior)</code></pre><p>Compute net inflow to soil layer.</p><p><strong>Ecoshift</strong></p><p>&quot; In this routine, infiltrating water (SLFL) is allocated to soil water in each layer (INFLIi ) and to bypass flow from each layer (BYFLIi ). The fraction of SLFL going to each layer (INFRACi ) is constant and is obtained in subroutine INFPAR. This fraction is separated into water to bypass flow (BYFLIi ) and water to the soil matrix (INFLIi ) by the bypass flow fraction (BYFRACi ) from subroutine BYFLFR. The routine then calculates net inflow to each layer, including withdrawal by transpiration and soil evaporation. INFLOW is called once each iteration time step and then is called once again if subroutine ITER produces a new, shorter, iteration time step.</p><p>The INFLOW routine is passed through once for each layer, working from the bottom up, preventing oversaturation of any layer. The total water allocated to layer i is</p><p>INFIL = INFRACi * SLFL.</p><p>Bypass flow rate is</p><p>BYFLIi = BYFRACi * INFIL</p><p>and the infiltration to soil matrix water in the layer is</p><p>INFLIi = INFIL - BYFLIi.</p><p>INFLOW next determines the maximum inflow rate (MAXINi ), to the layer that can be allowed in the iteration time-step. The vertical flow to the next layer down (VRFLIi ) (which may be negative), the transpiration withdrawal (TRANIi ), and the downslope flow (DSFLIi ) are fixed. So</p><p>MAXINi = (SWATMAXi - SWATIi) / DTI + VRFLIi + DSFLIi + TRANIi</p><p>where DTI is the iteration time step.</p><p>If VRFLIi-1 + INFLIi exceeds MAXIN, then oversaturation will occur. If BYFRACi &gt; 0, INFLIi is first reduced toward zero, then, if necessary, VRFLIi-1 is reduced, or even made negative if VRFLIi is negative. BYFLIi is increased by the amount that INFLIi is reduced. If BYFRACi = 0, VRFLIi-1 is reduced or even made negative. INFLOW finally calculates the net water flux rate, NTFLIi into each soil layer.</p><p>NTFLI(I%) = VV(I% - 1) + INFLI(I%) - VV(I%) - DSFLI(I%) - TRANI(I%)</p><p>where VV is the final value of VRFLI.</p><p>In the top layer, soil evaporation withdrawal is also added to MAXIN. Because there is no VRFLI(0) to reduce, excess water becomes negative INFLI(1) and increases BYFLI(1).</p><p>The modified values of VRFLIi are output from the INFLOW routine as variable VV because the original VRFLIi are needed again if the iteration time step (DTI) is reduced. &quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_WAT.jl#LL263-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.WAT.INFPAR-NTuple{4, Any}" href="#LWFBrook90.WAT.INFPAR-NTuple{4, Any}"><code>LWFBrook90.WAT.INFPAR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">INFPAR(p_INFEXP, p_ILAYER, p_soil, NLAYER)</code></pre><p>Compute fraction of infiltration to each soil layer.</p><p><strong>Arguments:</strong></p><ul><li><code>p_INFEXP</code>: infiltration exponent: 0 all to top, 1 uniform with depth, &gt;1.0=more at bottom than at top</li><li><code>p_ILAYER</code>: number of layers over which infiltration is distributed</li><li><code>p_soil</code></li><li><code>NLAYER</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_WAT.jl#LL49-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.WAT.KKMEAN-NTuple{4, Any}" href="#LWFBrook90.WAT.KKMEAN-NTuple{4, Any}"><code>LWFBrook90.WAT.KKMEAN</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">KKMEAN(KK_i, KK_iplus1, THICK_i, THICK_iplus1)</code></pre><p>Compute average hydraulic conductivity.</p><p>Note that between version 3.1 (where LWFBrook90 was forked), and 4.8 of Brook90 there were different variants how to compute the average.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_WAT.jl#LL236-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.WAT.VERT-NTuple{11, Any}" href="#LWFBrook90.WAT.VERT-NTuple{11, Any}"><code>LWFBrook90.WAT.VERT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VERT()</code></pre><p>Compute vertical flow rate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_WAT.jl#LL207-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.SUN.AVAILEN-NTuple{12, Any}" href="#LWFBrook90.SUN.AVAILEN-NTuple{12, Any}"><code>LWFBrook90.SUN.AVAILEN</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AVAILEN(SLRAD, p_fu_ALBEDO, p_C1, p_C2, p_C3, p_fT_TA, p_fT_VAPPRES, RATIO, p_fu_SHEAT, p_CR,
p_fu_LAI, p_fu_SAI)</code></pre><p>Estimate the available energy above and below the canopy.</p><p><strong>Ecoshift</strong></p><p>&quot; Estimates of available energy above and below the canopy are made in subroutine AVAILEN. Available energy is net radiation minus subsurface heat flux (SHEAT), and is the energy available for partitioning into heating the air and evaporating water. SHEAT is set to zero in code in MSBSETVARS.</p><p>AVAILEN calculates the available energies on an instantaneous basis, that is, in W/m2. MSBDAYNIGHT supplies to AVAILEN the average daytime solar radiation on the given slope (SLRAD, W/m2) as</p><p>SLRAD = SLFDAY * SOLRAD / (WTOMJ * DAYLEN)</p><p>where SOLRAD is the input daily solar radiation (MJ m-2) on a horizontal surface, and WTOMJ converts W m-2 to MJ m-2 d-1.</p><p>Net solar radiation (SOLNET) is</p><p>SOLNET = (1 - ALBEDO) * SLRAD</p><p>where ALBEDO is the albedo of the surface (above any canopy). When there is snow on the ground, albedo is the parameter ALBSN, otherwise it is the parameter ALB.</p><p>Estimation of net longwave radiation has been the subject of much research. BROOK90 uses Brutsaert&#39;s (1982) equation for effective clear sky emissivity (EFFEM)</p><p>EFFEM = 1.24 * [ EA * 10 / ( TA + 273.15 ] 1 / 7</p><p>where EA is the vapor pressure in kPa, and TA is the air temperature in °C. Alternative formulations for clear sky emissivity generally differ by 30 to 50 W/m2 in net longwave radiation under clear sky for the same temperature and humidity. This is equivalent to 1.1 to 1.8 mm/d of evaporated water, a substantial amount! The differences among equations were not systematic but depended on temperature and humidity (see the next section). Consequently the differences are reduced when totalled over a long time, and are further reduced by cloudiness. The Brutsaert equation is the most central.</p><p>A cloud cover correction (CLDCOR) to net longwave radiation has been used widely in the form</p><p>CLDCOR = C3 + ( 1 - C3 ) * NOVERN</p><p>where NOVERN is the sunshine duration for the day, normally written as n/N, or the fraction of possible hours of sunshine. C3 is a fixed parameter in BROOK90. NOVERN is obtained by inverting a common relation of solar radiation to sunshine duration to the form</p><p>NOVERN = ( RATIO - C1 ) / C2 , but not &lt; 0 or &gt; 1,</p><p>where RATIO is SOLRAD / I0HDAY, or the ratio of solar radiation to potential radiation on a horizontal surface, and C1 and C2 are empirical parameters.</p><p>The net longwave radiation (LNGNET) is</p><p>LNGNET = ( EFFEM - 1 ) * CLDCOR * SIGMA * ( TA + 273.15 )4</p><p>where SIGMA is the Stefan-Boltzmann constant. Then net radiation (RN) is</p><p>RN = SOLNET + LNGNET</p><p>and available energy above the canopy (AA) is</p><p>AA = RN - SHEAT.</p><p>Net radiation is assumed to be reduced exponentially down through the canopy according to an extinction coefficient (CR) and the sum of leaf area index (LAI) and stem area index (SAI), so the available energy at the ground (ASUBS) is</p><p>ASUBS = RN * exp [-CR * ( LAI + SAI ) ] - SHEAT.</p><p>Applying the extinction coefficient for photosynthetically-active radiation (CR) to net radiation as well is theoretically incorrect. The extinction coefficient for net radiation should be less than for PAR. But given the other uncertainties in both uses of CR there is not much point in differentiating the two values.</p><p>Clear-sky Longwave Radiation</p><p>A number of equations exist for estimating downward longwave radiation from clear sky, EFFEM, based only on weather station temperature and humidity. I have compared these methods by showing the net longwave radiation (to avoid the fourth power temperature response of the downward flux) as a function of temperature for three different relative humidities. I have not seen such a presentation in the literature, but it seems to show the differences among methods quite well.</p><p>Fig SUN-1Fig. SUN-1. Net longwave radiation from a clear sky estimated by five different equations, as a function of temperature for three relative humidities. The Y axis should read &quot;Net Longwave Radiation from Clear Sky&quot;.</p><p>The methods differ only in how they express EFFEM (e):</p><p>Brunt (1932)    e = ca + cb ea0.5 Satterlund (1979)   e = 1.08 {1 - exp[-(10 ea)K / 2016]} Brutsaert (1982)    e = 1.24 (10 ea / K)1/7 Idso and Jackson (1969) e = 1 - 0.261 exp(-0.000777 T2) Swinbank (1963) e = 0.0000092 K2 where ea is the vapor pressure in kPa, T is the temperature in °C, and K is the temperature in °K. The (mostly) upper Brunt curve has ca = 0.65, cb = 0.134 (kPa-0.5) (Fitzpatrick and Stern 1966), the middle curve has ca = 0.52, cb = 0.206 (Brunt 1932), and the lower curve has ca = 0.44, cb = 0.253 (Penman 1948). Note that the Swinbank and Idso-Jackson curves have no humidity dependence. Brutsaert (1982) admits that Satterlund&#39;s equation matches the data better below freezing, but Satterlund has a very flat temperature response and is the highest method of all for temperatures of 0 to 20°C and humidities above 60%. The Brutsaert method tends to be the most central over the whole range of possible conditions.</p><p>At most temperatures, the range of net longwave radiation is about 50 W/m2, which is equivalent to an evaporation of 1.8 mm/d! The choice of method for clear-sky emissivity thus plays a major role in the value of PE estimates when net radiation is estimated. A major effort using worldwide longwave data (not estimates from models!) will be needed to improve this situation. Fortunately, the cloud cover correction, approximate as it is, brings the net longwave closer to zero and helps wash out the emissivity error. &quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_SUN.jl#LL211-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.SUN.EQUIVSLP-Tuple{Any, Any, Any}" href="#LWFBrook90.SUN.EQUIVSLP-Tuple{Any, Any, Any}"><code>LWFBrook90.SUN.EQUIVSLP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EQUIVSLP(p_LAT, SLOPE, p_ASPECT)</code></pre><p>Correct solar radiation for slope and aspect and compute &quot;equivalent slope&quot; parameters.</p><p><strong>Ecoshift</strong></p><p>&quot; Correction of solar radiation for slope and aspect requires calculation of an &quot;equivalent slope&quot; in subroutine EQUIVSLP. The equivalent slope is defined as the location on the earth&#39;s surface where a horizontal surface is parallel to the given sloping surface. Following Swift (1976), L1 is the latitude of this &quot;equivalent slope&quot; (which is actually a horizontal surface), and L2 is the difference in hour angle (longitude) between the two locations. For any given slope and aspect, L1 and L2 need be found only once; they do not change over time. So they are calculated in EQUIVSLP at the beginning of B90, as:</p><p>L1 = ASIN[ COS(SLOPE) * SIN(LAT) + SIN(SLOPE) * COS(LAT)* COS(ASPECT) ] and L2 = ATAN { SIN(SLOPE) * SIN(ASPECT) /[ COS(SLOPE) * COS(LAT) - SIN(SLOPE) * SIN(LAT) * COS(ASPECT) ] }</p><p>with fixes for negative or zero denominator in L2, where SLOPE (ESLOPE), ASPECT, and latitude (LAT) are input parameters describing the location. All angles in the subroutine are in radians. &quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_SUN.jl#LL49-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.SUN.SUNDS-NTuple{8, Any}" href="#LWFBrook90.SUN.SUNDS-NTuple{8, Any}"><code>LWFBrook90.SUN.SUNDS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SUNDS()</code></pre><p>Return p<em>fT</em>DAYLEN, p<em>fT</em>I0HDAY, p<em>fT</em>SLFDAY.</p><p><strong>Ecoshift</strong></p><p>&quot; Several radiation-related variables depend only on day of the year and location. These are calculated in SUNDS, which is called once a day.</p><p>SUNDS requires the solar constant (SCD), which is the radiation (W/m2) on a surface normal to the sun outside the atmosphere. It depends on day-of-the-year (DOY) to determine the earth-sun distance and is</p><p>SCD = SC / (1 - .0167 * COS(.0172 * (DOY - 3))) ^ 2</p><p>where SC is the solar constant at the mean earth-sun distance (Swift 1976). SC is set to 1367 W/m2 (Lean 1991) and can not be changed.</p><p>The declination of the sun (DEC) is the angle by which the sun is above or below the plane of the earth&#39;s equator. DEC is zero at the equinoxes and +23.5° or -23.5 at the solstices. Swift (1976) gives the solar declination (radians) as:</p><p>DEC = ASIN { 0.39785 * SIN [ 4.86961 + 0.017203 * DOY + 0.033446 * SIN ( 6.224111 + 0.017202</p><ul><li>DOY ) ] }</li></ul><p>The daily integral of potential insolation on a slope (I0SDAY, MJ/m2) is given by Swift (1976) as:</p><p>I0SDAY = WTOMJ * SCD * FUNC3(DEC, L2, L1, T3, T2)</p><p>where</p><p>FUNC3 = (π/ 2) { SIN(DEC) * SIN(L1) * (T3 - T2) + COS(DEC) * COS(L1) * [ SIN(T3 + L2) - SIN(T2 + L2) ] }</p><p>is a program function and T2 and T3 are the hour angles of sunrise and sunset on the slope, which are obtained from function HAFDAY using the latitude of the equivalent slope. FUNC3 has units of d-1 and WTOMJ is the conversion factor 0.0864 (MJ m-2 d-1) / (W m-2). The actual SUNDS algorithm is more complicated than this because it must consider the possibility of two sunrises and sunsets on the slope in one day. The details of the algorithm are given by Swift (1976). Note that this algorithm assumes that the &quot;opposing slope&quot; is horizontal. In reality in mountainous terrain, the potential insolation is further reduced by any distant terrain that obscures the horizon more than the given slope itself does. The calculation of such obscuration is difficult and is outside the scope of BROOK90.</p><p>The daily integral of potential insolation on a horizontal surface (I0HDAY, MJ/m2) is found from the I0SDAY equation with L1 = LAT, L2 = 0, and T3 and T2 for a horizontal surface at LAT. The daylength (DAYLEN), which is the fraction of a day that the sun is above a horizontal horizon, is HAFDAY / π where function HAFDAY is used with L = LAT. SLFDAY is the ratio of I0SDAY to I0HDAY. SUNDS outputs DAYLEN, I0HDAY, and SLFDAY. &quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_SUN.jl#LL87-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.PET.ESAT-Tuple{Any}" href="#LWFBrook90.PET.ESAT-Tuple{Any}"><code>LWFBrook90.PET.ESAT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ESAT(TA_degC)</code></pre><p>Calculate saturated vp (kPa) and DELTA=dES/dTA (kPa/K) from temperature based on Murray J Applied Meteorol 6:203 (Magnus-Tetens) using as input TA_degC (air temperature in °C).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_PET.jl#LL475-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.PET.LWFBrook90_CANOPY-NTuple{8, Any}" href="#LWFBrook90.PET.LWFBrook90_CANOPY-NTuple{8, Any}"><code>LWFBrook90.PET.LWFBrook90_CANOPY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LWFBrook90_CANOPY()</code></pre><p>Compute evolution of plant parameters over the season.</p><p><strong>Ecoshift</strong></p><p>&quot; Subroutine CANOPY calculates plant &quot;parameters&quot; that can vary with day of the year ( DOY).</p><p>The height of the canopy above any snowpack, h (HEIGHT), is</p><p>HEIGHT = RELHIT * MAXHT - p<em>fu</em>SNODEP</p><p>where MAXHT is the maximum height for the year, which is an input parameter, and RELHIT is the relative height for the day of the year (doy), as obtained with function INTERP from the RELHT parameter array. HEIGHT is not allowed to be less than 0.01 m, which gives an appropriate roughness parameter for &quot;smooth&quot; surfaces. The snowpack depth (p<em>fu</em>SNODEP, m) is the snow water content (SNOW, mm) divided by 1000 times snow density (SNODEN), which is assumed constant. Although snow density can actually vary from 0.05 to 0.5, the constant value is good enough to account for burying of the canopy in BROOK90. The RATIO of uncovered HEIGHT to total height (RELHT * MAXHT) is also calculated.</p><p>Actual projected leaf area index, Lp (LAI), is</p><p>LAI = MAXLAI * RELLAI(DOY) * DENSEF * RATIO</p><p>where MAXLAI is the maximum LAI for the year, RELLAI(DOY) is the relative LAI for the doy as obtained with function INTERP from the RELLAI parameter array, DENSEF is a thinning parameter between zero and one (see below). The use of RATIO assumes that LAI is distributed uniformly with height. LAI is prevented from being less than 0.00001 to avoid zero divides; this can cause small amounts of transpiration, which may be ignored.</p><p>Actual projected stem area index Sp (SAI), is assumed proportional to HEIGHT following Federer et al. (1996), so</p><p>SAI = CS * HEIGHT * DENSEF</p><p>where CS is a parameter that is the ratio of SAI to HEIGHT.</p><p>Total root length per unit area (RTLEN) is</p><p>RTLEN = MXRTLN * RELHT * DENSEF</p><p>where MXRTLN is the maximum root length for the year. Correction for seasonal RELHT assumes that root length increases proportionally with height growth.</p><p>The total plant resistance to water movement (RPLANT) is</p><p>RPLANT = 1 / (MXKPL * RELHT * DENSEF)</p><p>where MXKPL is the plant conductivity at maximum height growth. RPLANT is not allowed to be greater than 1E8 MPa d/mm, which is effectively infinite. Correction for seasonal RELHT assumes that canopy conductance increases proportionally with height growth.</p><p>DENSEF is normally 1.0 in the above four equations. This parameter was included in the model as a convenient way to &quot;thin&quot; a canopy by removing a fraction of the plants. LAI, SAI, and RTLEN are all reduced proportionally to DENSEF, and RPLANT is increased. However DENSEF does NOT reduce HEIGHT because the remaining canopy still has the same height. Therefore DENSEF should NOT be set to 0 to simulate a clearcut as HEIGHT is unchanged and the aerodynamic resistances will be wrong. Probably DENSEF should not be less than 0.05. &quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_PET.jl#LL143-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.PET.PM-NTuple{5, Any}" href="#LWFBrook90.PET.PM-NTuple{5, Any}"><code>LWFBrook90.PET.PM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PM(AA, VPD, DELTA, RA, RC)</code></pre><p>Compute Penman-Monteith latent heat flux density, W/m2.</p><p><strong>Ecoshift</strong></p><p>&quot; The Penman-Monteith equation is</p><p class="math-container">\[L_v ρ_w E = \frac{Δ(Rn - S) + c_p ρ D_a / r_a}{Δ + γ + γ(r_c/r_a)}\]</p><p>or alternatively:</p><p class="math-container">\[L_v ρ_w E = \frac{r_a \cdot Δ \cdot(Rn - S) + c_p ρ D_a}{r_a \cdot (Δ + γ) + γ \cdot r_c }\]</p><p>where E is the evaporation rate in volume of water per unit land area per unit time, Lv is the latent heat of vaporization for water, ρw is the density of water, Δ is the rate of change of vapor pressure with temperature, Rn is the net radiation above the surface, S is the subsurface heat flux, cp is the heat capacity of air, ρr is the density of air, Da is the vapor pressure deficit in the air, γ is the psychrometer constant, rc is the &quot;canopy resistance&quot;, and ra is the aerodynamic resistance between the canopy and a reference height za at which Da is measured. The vapor pressure deficit, Da, is ea* - ea. The equation assumes that the vapor pressure at the effective evaporating surface, e0, is the saturated vapor pressure at the surface temperature. Then rc and ra are the two &quot;resistances&quot; through which water vapor passes as it moves down the vapor pressure gradient from e0 to ea. The canopy resistance, rc, represents resistance to flow of vapor through the stomates and cuticle of individual leaves and through the air around each leaf to some &quot;effective&quot; source height of water vapor in the plant canopy. The aerodynamic resistance, ra, is a measure of the turbulent transfer capability of the atmosphere between the effective source height and za. The Penman-Monteith equation is derived from the energy balance equation and the mass transfer equations for sensible and latent heat fluxes (e.g. Brutsaert 1982). &quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_PET.jl#LL1063-L1096">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.PET.ROUGH-NTuple{11, Any}" href="#LWFBrook90.PET.ROUGH-NTuple{11, Any}"><code>LWFBrook90.PET.ROUGH</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ROUGH()</code></pre><p>Compute canopy roughness height.</p><p><strong>Ecoshift:</strong></p><p>ROUGH obtains the roughness parameter, z0 , and the zero-plane displacement, d, based on canopy height, h, the projected leaf area index, Lp, and the projected stem area index, Sp. The methods used follow Shuttleworth and Gurney (1990) with some modifications. Shuttleworth and Gurney (1990) defined plant canopies as either &quot;closed&quot; or &quot;sparse&quot; based on whether Lp is greater or less than some arbitrary value Lpc, which they take as 4. Following Federer et al. (1996), BROOK90 defines a closed canopy as having Lp + Sp greater than Lpc + Spc, where Spc is taken as cs h, as described in the previous section. Spc is not reduced by DENSEF. RATIO is ( Lp + Sp ) / ( Lpc + Spc ) (this RATIO differs from RATIO in subroutine CANOPY). When RATIO is greater than or equal to 1, the canopy is &quot;closed&quot; and z0 and d are the values for a closed canopy.</p><p>The roughness parameter for closed canopies, z0c (Z0C), has been determined experimentally from wind profile data to be about 13% of h for relatively short canopies, but only 5% or less of h for some forests (Brutsaert 1982; Shuttleworth 1989). Following Federer et al. (1996) BROOK90 parameterizes the ratio z0c / h as follows: czs is the ratio for smooth surfaces with h less than hs; czr is the ratio for rough surfaces with h greater than hr; and for h between hs and hr, z0c is interpolated linearly between z0 = czs hs at h = hs and z0 = czr hr at h = hr. The effect of stems and branches is assumed to be included in z0c.</p><p>The zero-plane displacement of a closed canopy, dc (DISPC), is generally related to canopy height, h, and to z0c by</p><p>(22) dc = h - z0c / 0.3</p><p>(Monteith 1973; Shuttleworth and Gurney 1990).</p><p>When h (HEIGHT) is small, it is possible for z0c to be less than z0g (Z0GS), which is the parameter giving roughness of the ground surface under the canopy. This impossible situation would cause problems later on. It is prevented by reducing z0g to the value of z0c, which works nicely because z0c is always added to dc.</p><p>The values of d and z0 for sparse canopies (RATIO &lt; 1) are obtained by a modification of the method that Choudhury and Monteith (1988) developed from curves of Shaw and Pereira (1982). A drag coefficient per unit leaf area and stem area, cd (CDRAG), is calculated from z0c and dc as</p><p>(23) cd = { -1 + exp [ 0.909 - 3.03 ( z0c / h ) ] } 4 / (Lpc + Spc) .</p><p>This assumes that a unit of Spc produces the same drag as a unit of Lpc. Then</p><p>(24) d = 1.1 h ln { 1 + [ cd ( Lp + Sp ) ] 0.25 }.</p><p>Shuttleworth and Gurney (1990) also used this approach, but assumed a constant cd of 0.07, which is not appropriate when z0c / h is not 0.13.</p><p>For z0, Shuttleworth and Gurney (1990) chose between a sparse canopy equation and the closed canopy value of 0.3 (h - d), depending on a fixed value of cd Lp. However, that procedure leads to a step change at the transition. The step change is avoided by choosing the minimum of the two z0 values, as</p><p>(25) z0 = min { 0.3 ( h - d ), z0g + 0.3 h [ cd ( Lp+ Sp) ] 0.5 }</p><p>where z0g is the roughness parameter of the ground surface. When a snowpack is present, the value of z0g is replaced by the parameter Z0S before ROUGH is entered.</p><p>The reference height at which weather variables are known, za (ZA), is set to a fixed amount (ZMINH) above h. It thus is assumed to move up and down if h changes through the year.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_PET.jl#LL253-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.PET.SRSC-NTuple{15, Any}" href="#LWFBrook90.PET.SRSC-NTuple{15, Any}"><code>LWFBrook90.PET.SRSC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>SRSC()</p><p>Compute canopy surface resistance.</p><p><strong>Ecoshift</strong></p><p>&quot; This routine obtains the canopy surface resistance, rsc, which is the classic canopy resistance in the Penman-Monteith equation, using the Jarvis (1976) expression for the factors that control the individual leaf resistance, r, and its reciprocal the leaf conductance, g.</p><p>Confusion arises because r and g may be given on the basis of both total leaf surface area and projected leaf area. To straighten this out, consider that evaporation is the product of leaf conductance, g, in units of m3H2O m-2leaf s-1, and leaf area index, L, in units of m-2leaf m-2ground to give a canopy conductance in m3H2O m-2ground s-1. But the leaf area index can be given for projected leaf area, Lp, or for total leaf area, Lt. Similiarly, the conductance can be for projected leaf area, gp, or for total leaf area, gt. But the total evaporation must be the same, so gp Lp = gt Lt is required. In the literature, gt Lt is commonly used for needle-leaved plants and gp Lp for broadleaved plants. Following Körner et al. (1979) BROOK90 uses gp Lp for all plants. For needles, where gt, or its reciprocal rt, is known, then gp = ρ tp gt = ρtp / rt, where ρtp = Lt / Lp. Note that ρtp can vary from 2 for flat needles to π for cylindrical needles. For broad leaves, the leaf resistance is usually given separately as rb for the abaxial (lower) surface, and rd for the adaxial (upper) surface. Each of these is based on the one-sided area of the leaf or the projected leaf area index, so gp Lp = gb Lp + gd Lp = Lp ( 1 / rb + 1 / rd ). For amphistomatous leaves (stomates on both sides) the simplification gb = gd is often assumed, giving gp Lp = 2 gb. The factor of 2 can easily be confused with ρtp = 2, but they are not the same. For hypostomatous leaves (stomates only on the abaxial side), gd = 0 is often assumed, giving gp Lp = gd Lp. BROOK90 uses only gp, which hereafter is called gl, and is independent of assumptions about how gp was obtained.</p><p>Stomates open and close in response to several external and internal variables. Jarvis (1976) proposed that the effects could be considered as multiplicative such that</p><p>(26) gl = glmin + fT fD fR fW fC ( glmax - glmin )</p><p>where gl is the leaf conductance, glmin is its minimum value (closed stomates), glmax is its maximum value, and fT, fD, fR, fW, and fC are reduction factors, varying between 0 and 1, that account for effects of temperature, vapor pressure deficit, radiation (light), leaf water stress, and atmospheric carbon dioxide concentration, respectively, on stomatal opening. This multiplicative expression has been widely used, though more by default and for simplicity than because of any extensive empirical testing. BROOK90 is not concerned with effects of changing atmospheric CO2 effects, so fC = 1 always.</p><p>BROOK90 also always uses fw = 1. The resulting rsc is therefore appropriate to the definition of potential transpiration as occurring when soil water is at field capacity. Reduction of fw below 1 in response to drying soil would allow a direct calculation of actual transpiration using the Penman-Monteith or Shuttleworth-Wallace equations. However, BROOK90 does not do this; it simulates actual transpiration as the lesser of potential transpiration using fw = 1 and a supply rate controlled by the water potential gradient and plant resistance.</p><p>Of the remaining three dependencies, the temperature response is the least well-documented. Jarvis (1976) proposed a skewed parabolic response, such that stomatal conductance is reduced both by low and high temperatures. BROOK90 uses a slightly simpler response consisting of an optimum temperature range with fT = 1 and inverted half parabolas to reduce fT to 0 at each end of the range, so</p><p>(27)  fT = 0      Ta &lt; TL fT = 1 - [ (T1 - Ta) / (T1 - TL) ]2         TL &lt; Ta &lt; T1 fT = 1 T1 &lt; Ta &lt; T2 fT = 1 - [ (Ta - T2) / (TH - T2) ]2     T2 &lt; Ta &lt; TH fT = 0      Ta &gt; TH TL, T1, T2, and TH are all parameters. If T1 = T2, there is no optimum range. If TL = T1 and T2 = TH, fT is a square wave function. The use of mean daily temperature, Ta, here instead of some other temperature like minimum daily temperature is arbitrary. The actual temperature response is probably much more complex than this and involves acclimation.</p><p>Stomates are known to partially close in response to greater dryness of the air surrounding the leaf, though the mechanism is unclear. The dryness is expressed best by the vapor pressure difference between the leaf and its surrounding air, but as this is not generally known, the atmospheric vapor pressure deficit above the canopy, Da (VPD), is usually used. The error induced by using Da is certainly not larger than the uncertainty in the magnitude of the vapor deficit response for most species. Jarvis (1976) assumed a linear conductivity response, but Lohammar et al. (1980) suggest a linear resistance response such that</p><p>(28) fD = cD / ( cD + Da )</p><p>where cD (CVPD) is a constant, which is the Da at which fD = 0.5. This has the advantage of approaching 0 as an asymptote when Da is large.</p><p>For fR also, several functional forms have been used. BROOK90 uses the form given by Stewart (1988) in which fR = 1 when solar radiation incident on the leaf, RL, is equal to its nominal maximum value, Rm (1000 W/m2), so</p><p>(29) fR = (Rm + R0) RL / [ Rm (R + R0) ]</p><p>and R0 is a second parameter. A more convenient parameter than R0 is R.5, defined as the radiation level at which fR = 0.5. Then from (29)</p><p>(30) R0 = Rm / [ ( Rm / R.5 ) - 2 ]</p><p>For most plants, the value of R.5 is relatively low, around 50 to 100 W/m2. In these expressions, the solar radiation at the leaf is used, whereas the stomatal opening is actually influenced by the photosynthetically active radiation. Use of solar radiation, RL, therefore assumes that the spectral distribution of the radiation does not change with depth into the canopy, which is incorrect (Federer and Tanner 1966, can&#39;t resist the opportunity to quote my ancient Ph.D. work here!).</p><p>The canopy conductance, gsc, which is the reciprocal of rsc, is the integral of gl over each increment of total leaf area in the canopy , dL&#39; , so</p><p>With (26), where fT, fD, and glmax are all assumed constant through the canopy, (31) becomes</p><p>where fR is the only variable that depends on location in the canopy.</p><p>Integration of fR requires an expression for the penetration of solar radiation into the canopy. A Beer&#39;s Law or exponential extinction is commonly used, such that the average radiation flux density on the leaf surface, RL, at any level in the canopy depends on the projected leaf area, L&#39;, and projected stem area, S&#39;, above that level, as follows:</p><p>(33) RL = CR R exp [ -CR ( L&#39; + S&#39; ) ]</p><p>where CR is the extinction coefficient and R is the solar radiation at the top of the canopy. The first CR accounts for leaf inclination assuming random azimuthal distribution (Monteith 1973, Campbell 1977, Shuttleworth and Gurney 1990). The S&#39; term was added by Federer et al. (1996) and assumes that a unit of projected leaf area and a unit of projected stem area have the same absorption effect. Assuming that only half of Sp is distributed proportionally to L&#39; (and the other half is below the leaves in a &quot;stem space&quot;), then L&#39; + S&#39; = L&#39; + (L&#39;/Lp)(Sp/2) = fs L&#39; where fs = (Lp + Sp/2) / Lp. The integral in (32) using (29) and (33) is then</p><p>which corresponds to Shuttleworth and Gurney (1990) and Saugier and Katerji (1991) when Sp =</p><ol><li>The combination of (32) and (34) provides the value of rsc (RSC)</li></ol><p>&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_PET.jl#LL885-L1014">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.PET.SWGE-NTuple{8, Any}" href="#LWFBrook90.PET.SWGE-NTuple{8, Any}"><code>LWFBrook90.PET.SWGE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SWGE()</code></pre><p>Compute ground evaporation rate (mm/d) using Shuttleworth-Wallace with known transpiration.</p><p><strong>Ecoshift</strong></p><p>&quot; The Shuttleworth-Wallace approach incorporates the energy tradeoff between transpiration and soil evaporation. When transpiration is reduced by low availability of soil water or is zero, BROOK90 uses the new value of transpiration, Ec (ARATE), in subroutine SWGE to get a new value of soil evaporation, Es (ERATE). With Ec known, substituting (5) into (4) and (4) into (2) and solving for Lv ρw E gives (14) ... then (15) Lv ρw Es = Lv ρw E - Lv ρw Ec &quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_PET.jl#LL652-L668">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.PET.SWGRA-NTuple{13, Any}" href="#LWFBrook90.PET.SWGRA-NTuple{13, Any}"><code>LWFBrook90.PET.SWGRA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SWGRA()</code></pre><p>Compute Shuttleworth - Wallace - Gurney Aerodynamic Resistances.</p><p>The function computes and returns the aerodynamic resistances     <span>$r_a^a$</span> (source height to reference height),     <span>$r_a^c$</span> (leaf to zero plane), and     <span>$r_a^s$</span> (ground to source height),     see Shuttleworth and Gurney (1990).</p><p><strong>Ecoshift</strong></p><p>&quot; Shuttleworth - Wallace - Gurney Aerodynamic Resistances The three SW aerodynamic resistances, raa, ras, and rac are obtained in subroutine SWGRA by the methods of Shuttleworth and Gurney (1990). The derivations of their equations are not given here.</p><p>The friction velocity, u*, is first obtained from the classic logarithmic wind profile as</p><p class="math-container">\[(16) u^* = \frac{ k u_a }{ \log((z_a-d)/z_{0}) }\]</p><p>where ua is the wind speed at the reference height, za, z0 is the surface roughness parameter, d is the zero-plane displacement, and k is the von Karman constant. The roughness parameter is a measure of the turbulence-inducing properties of the surface. The zero-plane displacement, d, arises because the height of the effective canopy surface is above the ground surface that is taken as zero height. Both z0 and d are obtained in subroutine ROUGH . This u* equation strictly only applies for neutral atmospheric stability. Corrections for non-neutral stability are well-known (Brutsaert 1982), but are not usually considered where the objective is to evaluate PE for periods of a day and are not used in BROOK90.</p><p>Shuttleworth and Gurney (1990) assume that the classic logarithmic wind profile applies above the canopy and that an exponential profile applies within the canopy. As the canopy becomes sparser, they further assume that the effective source height of the energy fluxes remains at the same height as for a closed canopy, <span>$D_c = z_{0c} + d_c$</span>; these values are obtained in subroutine ROUGH. The ground to source height resistance, ras, is obtained by integrating the exponential eddy diffusivity from 0 to <span>$D_c$</span> to give</p><p class="math-container">\[(17) r_a^s = \frac{h \exp(n)}{ n K_h} \left(
        \exp\left( \frac{-n z_{0g} }{h} \right)  -
        \exp\left( \frac{-n D_c }{h}    \right)
    \right)\]</p><p>and the source height to reference height resistance, raa, is obtained by integrating from <span>$D_c$</span> to <span>$z_a$</span> as</p><p class="math-container">\[(18) r_a^a = \frac{ \log( \frac{z_a-d}{h-d} ) }{k u^*} +
        \frac{h}{n K_h} \left(
            -1 + \exp\left( n \frac{h-D_c}{h} \right)
        \right),\]</p><p>where n is the extinction coefficient for eddy diffusivity, <span>$z_{0g}$</span> is the roughness parameter of the underlying ground surface, and the eddy diffusivity at the canopy height, h, is</p><p class="math-container">\[(19) K_h = k u^* (h-d).\]</p><p>The exponential wind profile and the derived K(z) are known to be incorrect in canopies of intermediate leaf area index, but a better model is not yet available (Choudhury and Monteith 1988).</p><p>The leaf to zero plane resistance, rac, is assumed by Shuttleworth and Gurney (1990) to be a sum of the individual leaf laminar boundary layer conductances, so</p><p class="math-container">\[(20) r_a^c = \frac{r_b}{ρtp L_p}
           = \frac{1}{ρtp L_p}
              \frac{
                    \frac{n}{ab} \left( \frac{w}{u_h} \right)^{1/2}
                }{
                    \left( 1 - \exp( -n / 2 ) \right)
                },\]</p><p>where n is the extinction coefficient for eddy diffusivity, ab is a constant = 0.01 m/s0.5 (Campbell 1977), ρtp is the ratio of projected leaf area to total leaf surface area, Lp is the projected leaf area index, w is the representative leaf width in m, and uh is the wind speed in m/s at the top of the canopy. (Note that Shuttleworth and Gurney (1990) should have n in the numerator, not the denominator.) The <span>$r_a^c$</span> equation strictly applies only to flat leaves and needles, not to cylindrical needles; but <span>$r_a^c$</span> is small when w is small so this inaccuracy is negligible. The canopy-top wind speed, uh, is</p><p class="math-container">\[(21) u_h = (u^* / k) \log\left( \frac{h-d}{z_0} \right).\]</p><p>In the Shuttleworth and Gurney equation, rac goes to infinity as Lp goes to zero, but this neglects the contribution of stems and branches to interception loss, especially when Lp = 0. Although the <span>$r_a^c$</span> equation is specifically for leaves with width w, subroutine SWGRA uses (ρtp Lp + π Sp) for r tp Lp in equation (20), where Sp is the projected stem area index, defined analagous to Lp as the ratio of projected surface area of stems and branches to ground area (Federer et al. 1996). This assumes that a unit of stem surface has the same influence on rac as a unit of leaf surface. To avoid zero divides when Sp = 0, Lp is prevented from being less than 0.00001.</p><p>The Shuttleworth - Gurney separation of rac and rsc at the canopy level rather than at the leaf level is theoretically incorrect. In reality, the leaf boundary layer resistance and the leaf diffusion resistance are in series on each side of flat leaves (Jarvis and McNaughton 1986). The two resistances should be summed over each side of the leaf before integrating over the canopy, but this is too complicated for practical application (Choudhury and Monteith 1988). &quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_PET.jl#LL690-L799">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.PET.SWPE-NTuple{9, Any}" href="#LWFBrook90.PET.SWPE-NTuple{9, Any}"><code>LWFBrook90.PET.SWPE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SWPE(AA, ASUBS, VPD, RAA, RAC, RAS, RSC, p_fu_RSS, DELTA)</code></pre><p>Compute Shuttleworth and Wallace (1985) transpiration and ground evaporation.</p><p><strong>Ecoshift</strong></p><p>&quot; Shuttleworth and Wallace (1985) (SW) modified the Penman-Monteith method to account separately for the different water vapor and sensible heat pathways from the soil and from the leaves. Instead of the two resistances of equation (1), rc and ra, SW define five: rsc, raa, rac, ras, and rss. Resistances rsc and rac are in the transpiration pathway while rss and ras are in the soil evaporation pathway and raa is common to both. The canopy surface resistance, rsc, is the resistance to movement of water vapor out of the leaves. The resistance rac restricts vapor movement from the leaf surfaces to the effective source height for water vapor in the canopy. The resistance between the source height and a reference height above the canopy is raa, which corresponds to ra in equation (1). The reference height is that at which air temperature, humidity, and wind speed are known. The resistance to movement of water vapor from inside the soil to the soil surface is rss. The resistance to vapor movement from the soil surface to the source height is ras. The resistances rac, ras, and raa are assumed also to apply to sensible heat transfer.</p><p>Shuttleworth and Wallace (1985) start with</p><p>(2) Lv ρw E = Lv ρw Ec + Lv ρw Es</p><p>where Ec is transpiration and Es is soil evaporation, then write an equation similar to (1) for each term</p><p>where D0 is the vapor pressure deficit at the effective source height, A is Rn - S or the available energy above the canopy, and As is Rns - S or the available energy at the ground. From the relationships of sensible and latent fluxes to the gradients and resistances, and using the definition of Δ, Shuttleworth and Wallace obtain</p><p>(5) D0 = Da + raa [Δ A - (Δ + γ) Lv ρw E ] / cpρ</p><p>Algebraic manipulation of (2), (3), and (4) to eliminate D0 leads to:</p><p>(6) Lv ρw E = Cc Mc + Cs Ms</p><p>where</p><p>(9) Cc = 1 / { 1 + Rc Ra / [ Rs ( Rc + Ra ) ] }</p><p>(10) Cs = 1 / { 1 + Rs Ra / [ Rc ( Rs + Ra ) ] }</p><p>with</p><p>(11) Ra = (Δ + g) raa</p><p>(12) Rs = (Δ + γ) ras + γ rss</p><p>(13) Rc = (Δ + γ) rac + γ rsc</p><p>Although the algebra appears complicated, these equations for the first time provide a PM-type theory that includes both transpiration and soil evaporation. The total evaporation, E, must be obtained from (6) first, then D0 from (5), before the two components can be calculated from (3) and (4). Subroutine SWPE includes equations (3) through (13), more or less in reverse order.</p><p>The outputs Ec (PRATE) and Es (ERATE) from SWPE are in units of mm/d whereas Lvρw E in (1) is output as W m-2 from function PM. The conversion is ETOM * WTOMJ . &quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_PET.jl#LL546-L609">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.PET.WEATHER-NTuple{14, Any}" href="#LWFBrook90.PET.WEATHER-NTuple{14, Any}"><code>LWFBrook90.PET.WEATHER</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">WEATHER()</code></pre><p>Compute solar radiation, temperature and wind speed.</p><p><strong>Ecoshift</strong></p><p>WEATHER includes all adjustments of input weather data, including separation into daytime and nighttime values.</p><p>If daily solar radiation (SOLRAD) is input as zero, it is estimated as 0.55 * I0HDAY, or 55% of the potential solar radiation for the doy and location. The 0.55 value is an overall generalization for the United States, where values range from 0.50 in the east to 0.60 in the west (U.S. Department of Commerce 1968). As of Version 4.8 this value can be changed on the BROOK90 main window.</p><p>If vapor pressure (EA) is input as zero, it is estimated as the saturated vapor pressure at the minimum daily temperature (TMIN) using subroutine ESAT.</p><p>If daily average wind speed at a weather station (UW) is input as zero, it is estimated as 3 m s-1. This is a surprisingly good approximation for most weather stations in the United States at all seasons of the year (U.S. Department of Commerce 1968). For other default values, enter the value as UA for each day in the data file. Note: measured values of zero wind speed should be entered as 0.1.</p><p>The average temperature for the day (TA) is taken as the average of the input maximum and minimum temperatures (TMAX and TMIN). Daytime (TADTM) and nighttime (TANTM) average temperatures are calculated by assuming a sine wave variation between TMAX and TMIN. Integration leads to</p><p>TADTM = TA + [ (TMAX - TMIN) / (2 π DAYLEN) ] sin( π DAYLEN )</p><p>TANTM = TA - { (TMAX - TMIN) / [2 π (1 - DAYLEN)] } sin( π DAYLEN )</p><p>where DAYLEN is the solar daylength determined in subroutine SUNDS.</p><p>For wind speed, a parameter, WNDRAT, defines the average ratio of nighttime wind speed (UANTM) to daytime wind speed (UADTM). The default value for WNDRAT is 0.3 based on Hubbard Brook data.</p><p>UADTM = UA / [ DAYLEN + (1 - DAYLEN) WNDRAT ]</p><p>UANTM = WNDRAT * UADTM</p><p>where UA is the daily average wind speed at height za.</p><p>TA, UA, and the vapor pressure, EA, which is assumed constant over the day, are all theoretically the values at the reference height above the canopy (ZA) . In practice, these values are rarely measured above the canopy of interest, but are usually from some relatively nearby weather station. Any attempt to theoretically adjust TA and EA would require some information on their profiles, such as surface temperature and vapor pressure, which are not known. So BROOK90 assumes that TA and EA are the same at the weather station and at za. However, UA can be estimated from wind speed at the weather station (UW) because wind speed extrapolates to zero at height z0 + d over both surfaces. This adjustment is done in function WNDADJ. UW is prevented from being less than 0.2 m s-1.</p><p>Subroutine WEATHER could be modified to do further adjustments to temperature, vapor pressure, and wind. For instance, an elevation adjustment to temperature could be added, using the average environmental lapse rate of -0.6°C / 100m.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_PET.jl#LL363-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.PET.WNDADJ-NTuple{6, Any}" href="#LWFBrook90.PET.WNDADJ-NTuple{6, Any}"><code>LWFBrook90.PET.WNDADJ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">WNDADJ(p_fu_ZA, p_fu_DISP, p_fu_Z0, p_FETCH, p_ZW, p_Z0W)</code></pre><p>Compute ratio of wind speed at reference height (above canopy) to wind speed at weather station.</p><p><strong>Ecoshift</strong></p><p>&quot; This function estimates the wind speed (UA) at reference height ZA above the canopy from input wind speed at a remote weather station (UW). Assume that the weather station represents a new surface downwind that has a roughness of z0w (Z0W) and a fetch of F (FETCH). Brutsaert (1982) gives the height of the internal boundary layer, zb, as</p><p class="math-container">\[z_b = 0.334 F^{0.875} z_{0w}^{0.125}\]</p><p>For logarithmic wind profiles over both surfaces to have the same wind speed at zb,</p><p class="math-container">\[u_a = u_w \left( \frac{
    \log(z_b/z_{0w}) \log((z_a-d)/z_{0})
    }{
    \log(z_b/z_{0}) \log(z_{w}/z_{0w})
    } \right)\]</p><p>where zw (ZW) is the height of wind measurement at the weather station (Federer et al. 1996) and d (DISP) is the zero-plane displacement of the canopy. This assumes that the weather station is over a smooth surface so its zero plane displacement can be ignored. If the parameter Z0W is set to zero, then no adjustment is made and ua = uw. &quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_PET.jl#LL504-L535">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.SNO.SNOENRGY-NTuple{10, Any}" href="#LWFBrook90.SNO.SNOENRGY-NTuple{10, Any}"><code>LWFBrook90.SNO.SNOENRGY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SNOENRGY(p_fu_TSNOW, p_fT_TA, p_fT_DAYLEN, p_CCFAC, p_MELFAC, p_fT_SLFDAY, p_fu_LAI,
p_fu_SAI, p_LAIMLT, p_SAIMLT)</code></pre><p>Compute energy flux density to snow surface, MJ m-2 d-1.</p><p><strong>Ecoshift</strong></p><p>&quot; The energy flux density to the snow surface (SNOEN, MJ m-2 d-1) is calculated in subroutine SNOENRGY independently of precipitation for the day.</p><p>When TA is &lt;= 0°C, SNOEN is the energy used to heat or cool the snowpack</p><p>SNOEN = CCFAC * 2 * DAYLEN * (TA - TSNOW)</p><p>where CCFAC is an input parameter, and DAYLEN is the daytime fraction of a day. CCFAC is the below-zero degree-day factor for a day with a daylength of 0.5 d. Anderson (1973) pointed out that this degree-day factor appears to vary seasonally. In BROOK90, this seasonality is incorporated by using 2 * DAYLEN as a multiplier in the above equation. BROOK90 is not very sensitive to CCFAC unless it is close to 0; larger values of CCFAC make the snow melt later because the snowpack cools more. When CCFAC = 0, snow temperature is always 0°C and there is never any cold content.</p><p>When TA is greater than 0°C, energy is provided that can melt snow, and SNOEN is calculated differently. The energy supply rate, SNOEN, is then</p><p>SNOEN = MELFAC * 2 * DAYLEN * SLFDAY * TA * exp(-LAIMLT * LAI - SAIMLT * SAI)</p><p>where MELFAC is the melting degree-day factor for a day with a daylength of 0.5 d and no canopy, SLFDAY is the ratio of potential insolation on the slope to that on a horizontal surface, and the input parameters LAIMLT and SAIMLT express the dependence of SNOEN on leaf area index (LAI) and stem area index (SAI). MELFAC uses 0°C as a base and is zero for TA below this. Inclusion of SLFDAY in the MELT equation arises from an assumption that radiation melt plays an important role. If this is not so, then SLFDAY multiplier could be omitted, and snowmelt would not depend on slope-aspect. The functional forms of the SAI and LAI dependencies are based on the somewhat arbitrary curves used by Federer and Lash (1978). &quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_SNO.jl#LL185-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.SNO.SNOFRAC-Tuple{Any, Any, Any}" href="#LWFBrook90.SNO.SNOFRAC-Tuple{Any, Any, Any}"><code>LWFBrook90.SNO.SNOFRAC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SNOFRAC(p_fT_TMAX, p_fT_TMIN, p_RSTEMP)</code></pre><p>Separate RFAL from SFAL.</p><p><strong>Ecoshift</strong></p><p>&quot; Separation of daily precipitation into snow or rain is a major problem in hydrologic modeling. For instance, if the wrong precipitation form is chosen in December, simulated streamflow from that day&#39;s precipitation could be shifted from December to April or vice versa, a rather significant effect! BROOK90 uses both daily maximum (TMAX) and daily minimum (TMIN) temperatures to allow days on which mixed rain and snow falls. This reduces the potential error from making the wrong choice. The algorithm seems to have been stated first by Willen and Shumway (1971). When TMAX for the day is greater than the parameter RSTEMP and TMIN is less than RSTEMP, the fraction of precipitation as snow, SNOFRC, is</p><p>SNOFRC = (RSTEMP - TMIN) / (TMAX - TMIN)</p><p>where RSTEMP is the &quot;base&quot; temperature for the rain-snow transition. When TMAX &lt; RSTEMP, SNOFRC = 1; when TMIN &gt; RSTEMP, SNOFRC = 0. The default value of RSTEMP is -0.5°C because that seems to work best at Hubbard Brook. If precipitation is input more than once a day, the same SNOFRC is used for all precipitation intervals. &quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_SNO.jl#LL74-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.SNO.SNOVAP-NTuple{17, Any}" href="#LWFBrook90.SNO.SNOVAP-NTuple{17, Any}"><code>LWFBrook90.SNO.SNOVAP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SNOVAP(p_fu_TSNOW, p_fT_TA, p_fT_VAPPRES, UA, p_fu_ZA, p_fu_HEIGHT, p_fu_Z0, p_fu_DISP,
p_fu_Z0C,p_fu_DISPC, p_fu_Z0GS, p_LWIDTH, p_RHOTP, p_NN, p_fu_LAI, p_fu_SAI, p_KSNVP)</code></pre><p>Compute potential snow evaporation (mm/d).</p><p><strong>Ecoshift</strong></p><p>&quot; Evaporation rate from the snowpack, and its negative, condensation, are evaluated using the aerodynamic flux equation</p><p>E = (cp ρ / g Ls rw ) (e0 - ea) / (raa + ras)</p><p>where ea is the vapor pressure of the air, e0 is the surface vapor pressure, and raa and ras are the Shuttleworth-Wallace resistances described in section PET. The constants cp ρ (CPRHO), γ (GAMMA), and the latent heat of sublimation Ls ρw (LS) are constant. BROOK90 assumes that the snowpack is always isothermal and that its temperature does not change diurnally. When the snowpack temperature (TSNOW) is less than 0°C, the surface vapor pressure, e0, is the saturated vapor pressure at TSNOW and is obtained by calling subroutine ESAT. When TSNOW is 0°C, e0 is 0.61 kPa; use of Ls instead of the latent heat of vaporization, Lv, in this case is slightly wrong. The vapor pressure ea (EA) is the input vapor pressure at reference height za . The resistances raa and ras are obtained from subroutine SWGRA using the daily average wind speed (UA). The value of E in mm/d returned from SNOVAP is called PSNVP because it can be reduced in SNOWPACK if snow disappears.</p><p>For evaporation from snow in the open, U.S. Army Corps of Engineers (1956) gives</p><p>E = 1.9 ua (e0 - ea)</p><p>for evaporation in the open. This yields E = 0.6 mm when ua = 3 m/s and the vapor pressure difference is 0.1 kPa. The two E equations are the same when ras = 0, za - d = 2 m, and z0 = 1 mm. Subroutine SWGRA thus gives the appropriate raa for snow in the open.</p><p>Colbeck et al. (1979) state &quot;Evaporation from the snow in a forest has received a great deal of attention, with many investigators concluding that it is small.... Although there are many reports of high evaporative losses from forests, these have not been verified from heat balance considerations.&quot; Generally, literature values are around 0.5 mm/d in the open, with monthly values around 10 mm and annual values of 20 mm or more. Anderson (1976) gives 15-20 mm annually for Sleepers River, VT.</p><p>The modified Shuttleworth and Gurney resistance formulations in subroutine SWGRA for a leafless tall canopy give raa about 3 s/m and ras about 40 s/m for a weather station wind speed of 3 m/s. A common vapor pressure difference of 0.1 kPa then gives a very high evaporation of 1.6 mm/d or 50 mm/ month. The problem may be that the resistances calculated by SWGRA are too small, either because of too large a roughness parameter for leafless deciduous forests, or because stability effects are ignored. To fix the problem BROOK90 includes KSNVP, which is an arbitrary constant multiplier of PSNVP. Use KSNVP = 1.0 for open open areas or short canopies normally covered by snow; but for forest, KSNVP of 0.3 gives more reasonable values of SNVP. More work is obviously needed on amount and theory of snow evaporation under forests.</p><p>Note that although evaporation and condensation of water are simulated in SNOVAP, the accompanying latent transfer is not simulated. The snow energy balance in subroutine SNOENRGY is (unfortunately) decoupled from the snow evaporation-condensation process. &quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_SNO.jl#LL109-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.SNO.SNOWPACK-NTuple{14, Any}" href="#LWFBrook90.SNO.SNOWPACK-NTuple{14, Any}"><code>LWFBrook90.SNO.SNOWPACK</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SNOWPACK(p_fu_RTHR, p_fu_STHR, p_fu_PSNVP, p_fu_SNOEN, u_CC, u_SNOW,
u_SNOWLQ, p_DTP, p_fT_TA, p_MAXLQF, p_GRDMLT,
p_CVICE, p_LF, p_CVLQ)</code></pre><p>Update status of snowpack. Generally it computes in terms of mass balance:     u<em>SNOW</em>new = u<em>SNOW + p</em>DTP * (p<em>fu</em>STHR + aux<em>du</em>RSNO - aux<em>du</em>SMLT - aux<em>du</em>SNVP)</p><p>However, there are numerous checks involved regarding availability of snow and energy that modify the above mentioned mass fluxes. The subroutine returns the magnitude of these fluxes in [mm/day] enabling the separate use of them for the isotope mass balance.</p><p><strong>Ecoshift</strong></p><p>&quot; In each precipitation interval, throughfall of rain (RTHR) and throughfall of snow (STHR) are calculated and subroutine SNOWPACK is entered if there is STHR or if there is SNOW. This subroutine adds throughfall to the snowpack, subtracts groundmelt, snow evaporation, and drainage of liquid water, and calculates the new cold content (CC) and liquid water content (SNOWLQ) of the snowpack. There are a number of different ways to program all this adding and subtracting of energy and water. The program flow of SNOWPACK has been selected to make the many realizable situations as clear as possible. Much shorter algorithms could have been used, but at the expense of clarity. Any alterations to this routine must be made carefully, keeping all the possibilities in mind. However, unlike routine SNOENRGY, the content of the SNOWPACK routine is essentially standard for all snow models and alterations generally should not be necessary.</p><p>In SNOWPACK, snow throughfall (STHR) is first added to SNOW. If TA is &lt;0°C, the cold content of the new snow is increased by</p><p>CC = CC - CVICE * TA * STHR * DTP</p><p>where DTP is the precipitation interval time step and CVICE is the volumetric heat capacity of ice. If this addition of cold snow causes both cold content (CC) and liquid water (SNOWLQ) to coexist, then liquid water is refrozen; CC is used to refreeze part or all of the liquid.</p><p>Groundmelt (GRDMLT) and snow evaporation-condensation are dealt with next. In the precipitation time interval (DTP), the fraction of the snowpack that melts by groundmelt and evaporates is</p><p>FRAC = (GRDMLT + PSNVP) * DTP / SNOW.</p><p>If FRAC is &gt; 1 then all the snow melts and evaporates at rates proportional to GRDMLT and PSNVP. If FRAC is &lt; 1, SNVP is equal to potential snow evaporation (PSNVP) and GRDMLT drains from the snowpack as snowmelt (SMLT). An assumption is made that evaporation and groundmelt remove any liquid water and cold content that is associated with the snow removed, so SNOW, SNOWLQ, and CC are all reduced by 1 - FRAC. If PSNVP is negative, condensation is occurring; SNOW, SNOWLQ, and CC are correspondingly increased. This is simple, but not quite accurate. If no snow is left the routine ends.</p><p>The amount of snowpack warming or cooling is calculated next. The equivalent amount of ice melted by the energy input from SNOEN and the heat included in any warm rain is</p><p>EQEN = DTP * (SNOEN + RTHR * RMAX(TA, 0) * CVLQ) / LF</p><p>where CVLQ is the specific heat of water, and LF is the latent heat of fusion of water. Both CVLQ and LF are constant. When EQEN is less than 0, the snow is cooling; first any SNOWLQ is refrozen, then CC is increased. CC is not allowed to be reduced so that TSNOW is below the mean daily air temperature, TA, although it may remain colder, i.e. if TA &lt; 0°, CC can only be reduced to TSNOW = TA. When EQEN is greater than 0, the snow is warming; first CC is reduced, then SNOWLQ is produced, and finally melt (SMLT) occurs.</p><p>Finally, any rain throughfall (RTHR) is added to the snowpack. If any CC exists it refreezes rain until the CC is &quot;used up&quot;. Any additional rain then increases SNOWLQ; when the maximum SNOWLQ is reached, the input of rain to the snow (RSNO) has also reached its maximum. In all cases the final results are a new SNOW, new SNOLQ and CC, and a value of RSNO.</p><p>MSBPREINT then calculates the rain passing through the snow (RNET) as</p><p>RNET = RTHR - RSNO.</p><p>When SNOW exists at the beginning of the day, soil evaporation (SLVP) is zero. &quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_SNO.jl#LL236-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.EVP.INTER-NTuple{10, Any}" href="#LWFBrook90.EVP.INTER-NTuple{10, Any}"><code>LWFBrook90.EVP.INTER</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">INTER(p_fT_RFAL, p_fu_PINT, p_fu_LAI, p_fu_SAI, p_FRINTL, p_FRINTS, p_CINTRL, p_CINTRS, p_DTP, u_INTR)</code></pre><p>Compute rain catch rate (interception) and evaporation rate of intercepted rain in mm/d.</p><p>Rain interception, used when p_NPINT &gt; 1.</p><p><strong>Arguments</strong></p><ul><li><code>p_fT_RFAL</code>: rainfall rate, mm/d</li><li><code>p_fu_PINT</code>: potential interception rate, mm/d</li><li><code>p_fu_LAI</code>: projected leaf area index, m2/m2</li><li><code>p_fu_SAI</code>: projected stem area index, m2/m2</li><li><code>p_FRINTL</code>: intercepted fraction of p<em>fT</em>RFAL per unit p<em>fu</em>LAI</li><li><code>p_FRINTS</code>: intercepted fraction of p<em>fT</em>RFAL per unit p<em>fu</em>SAI</li><li><code>p_CINTRL</code>: maximum interception storage of rain per unit p<em>fu</em>LAI, mm</li><li><code>p_CINTRS</code>: maximum interception storage of rain per unit p<em>fu</em>SAI, mm</li><li><code>p_DTP</code>: precipitation interval time step, d</li><li><code>u_INTR</code>: intercepted rain storage, mm,</li></ul><p><strong>Ecoshift:</strong></p><p>Older studies of rain and snow interception regressed throughfall on precipitation, but such interpretation ignored the fact that energy supply rather than water supply may limit interception and also ignores storm duration/intensity and interstorm interval. Detailed simulation models of rain interception over time through a storm have been developed (Rutter et al. 1972) but these are too complex to include in a hydrologic model like BROOK90. Much less is known about the complicated process of evaporation of intercepted snow.</p><p>Subroutine INTER accounts in the simplest way for the concepts of catch rate, evaporation rate, and canopy capacity. The same algorithm is applied to both rain and snow, which are considered to behave independently with respect to their interception. INTER is used when precipitation data are input more than once a day in a precip. interval file (PINT &gt; 1). If only daily precipitation is input, then the modified procedure of INTER24 is used.</p><p>The conservation of mass equation for rain interception can be written as</p><p>dS/dt = C - I - D</p><p>where S is the amount of water stored on the canopy (mm), C is the catch rate, or rate of water input to the canopy, I is the rate of evaporation of intercepted water, and D is the drip rate, or rate of transfer of liquid water to the ground. The same equation applies to snow or mixed snow and rain, when any solid-liquid phase change is ignored and D includes all rain or snow blowing or falling from canopy to ground.</p><p>BROOK90 ignores D by defining C as a net catch rate (C - D), or only the portion of the catch that will sooner or later evaporate, so, from the Flow Chart,</p><p>d INTR / dt = RINT - IRVP</p><p>for rain, and</p><p>d INTS / dt = SINT - ISVP</p><p>for snow, where INTR and INTS are the canopy storages, RINT and SINT are the net catch rates, and IRVP and ISVP are the evaporation rates, for rain and snow respectively.</p><p>BROOK90 assumes that interception catch rates, RINT and SINT, are a constant fraction of rainfall or snowfall until the canopy reaches a storage capacity. Until the capacity is reached, RINT and SINT are assumed to be linear functions of LAI and SAI, so that</p><p>RINT = (FRINTLAI * LAI + FRINTSAI * SAI) * RFAL</p><p>and</p><p>SINT = (FSINTLAI * LAI + FSINTSAI * SAI) * SFAL</p><p>where RFAL and SFAL are rainfall rate and snowfall rate as determined from subroutine SNOFRAC, FRINTLAI and FSINTLAI are the catch fraction per unit LAI for rain and snow, respectively, and FRINTSAI and FSINTSAI are the catch fraction per unit SAI for rain and snow, respectively.</p><p>The canopy has capacities or maximum values of INTR and INTS that depend on LAI and SAI. In BROOK90 these dependencies are assumed linear. The parameters CINTRL and CINTRS are the capacities for intercepted rain per unit LAI and SAI respectively, so that INTRMX, the capacity for rain, is</p><p>INTRMX = CINTRL * LAI + CINTRS * SAI.</p><p>For snow,</p><p>INTSMX = CINTSL * LAI + CINTSS * SAI,</p><p>and the capacity parameters are generally larger than for rain. The eight interception parameters, FRINTLAI, FRINTSAI, FSINTLAI, FSINTSAI, CINTRL, CINTRS, CINTSL, and CINTSS, only control interception loss in small storms; interception loss in large storms is controlled by the evaporation rate of intercepted water (PINT) and the storm intensity and duration.</p><p>The rate at which intercepted water evaporates (PINT) is calculated from the Shuttleworth-Wallace equations by calling subroutine SWPE (Section PET) with the canopy resistance rc = 0. The soil surface resistance (RSS) is not reduced for the PINT calculation. The MSBDAYNIGHT routine does this separately for daytime and for nighttime weather variables and the results are weighted by daylength (DAYLEN) to produce PINT. PINT is considered to be constant throughout the daily time step; its actual diurnal variation is ignored.</p><p>The canopy is considered to be either completely wetted or completely dry. Partial canopy wetting and drying is not treated in BROOK90, though it is a key component of specific models of the interception process (Rutter et al. 1972). Subroutine INTER determines the actual catch rate (RINT or SINT) and the actual evaporation rate (IRVP or ISVP) for the precipitation time step in the three cases that the canopy dries during the timestep, the canopy wets but does not reach capacity, and the canopy reaches capacity. The routine appropriately handles the case of a wet canopy with decreasing capacity because of decreasing LAI or SAI by allowing RINT or SINT to be negative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_EVP.jl#LL400-L502">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.EVP.INTER24-NTuple{11, Any}" href="#LWFBrook90.EVP.INTER24-NTuple{11, Any}"><code>LWFBrook90.EVP.INTER24</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">INTER(p_fT_RFAL, p_fu_PINT, p_fu_LAI, p_fu_SAI, p_FRINTL, p_FRINTS, p_CINTRL, p_CINTRS, p_DTP, u_INTR)</code></pre><p>Compute rain catch rate (interception) and evaporation rate of intercepted rain in mm/d.</p><p>Rain interception with duration in hours, used when p_NPINT = 1. Same routine is used for snow interception, with different calling variables.</p><p><strong>Arguments:</strong></p><ul><li><code>p_fT_RFAL</code>: 24-hour average rainfall rate, mm/d</li><li><code>p_fu_PINT</code>: potential interception rate, mm/d</li><li><code>p_fu_LAI</code>: projected leaf area index, m2/m2</li><li><code>p_fu_SAI</code>: projected stem area index, m2/m2</li><li><code>p_FRINTL</code>: intercepted fraction of p<em>fT</em>RFAL per unit p<em>fu</em>LAI</li><li><code>p_FRINTS</code>: intercepted fraction of p<em>fT</em>RFAL per unit p<em>fu</em>SAI</li><li><code>p_CINTRL</code>: maximum interception storage of rain per unit p<em>fu</em>LAI, mm</li><li><code>p_CINTRS</code>: maximum interception storage of rain per unit p<em>fu</em>SAI, mm</li><li><code>p_DURATN</code>: average storm duration, hr</li><li><code>u_INTR</code>: intercepted rain storage, mm,</li><li><code>MONTHN</code>: Month of the year</li></ul><p><strong>Ecoshift:</strong></p><p>&quot; Subroutine INTER24 - daily interception Proper representation and integration of the interception process is a problem for hydrologic models that use a daily interval for precipitation input (p_NPINT = 1), because the storm duration is not known. For a brief, intense storm, the canopy wets once and the interception loss is limited primarily by canopy capacity. For a low intensity, all day storm, the canopy stays wet and the interception loss is limited primarily by the potential interception, PINT. This problem is worst when only daily precipitation is known, and decreases as precipitation is given at shorter intervals.</p><p>Subroutine INTER24 was developed because the use of subroutine INTER for daily precipitation consistently produced too much interception. INTER24 is a modification of INTER that loops through the procedure every hour,using the PINT rate for each hour. DURATN is a parameter that specifies the average hourly duration of precipitation for each month of the year. INTER24 truncates DURATN to the next lower even integer, and then centers the &quot;storm&quot; on noon. Thus if DURATN is input as 7.5, the daily precipitation is assumed to occur at a constant rate from time 0900 to 1500. Centering on noon is only used to see how much interception carries over into the next day. The algorithm for each hourly loop is the same as for INTER, except that rates are in mm/hr and amounts are summed over the day. The interception catch rate (RINT or SINT), and the evaporation rate (IRVP or ISVP) are returned to MSBPREINT as average rates over the day.</p><p>To determine appropriate values of DURATN I examined hourly precipitation data for 4 years (one year at Hubbard Brook) from the SAMSON data set. Averaging the number of hours per day of precipitation of 0.02 inch (0.5 mm) or greater over days with such precipitation gave the following results after a little smoothing</p><pre><code class="nohighlight hljs">                    J   F   M   A   M   J   J   A   S   O   N   D
San Juan PR         3   2   2   2   2   2   2   3   3   3   3   3
Atlanta GA          5   5   5   5   4   4   3   3   4   4   5   6
Caribou ME          4   4   5   5   4   4   4   4   4   6   6   5
Madison WI          4   4   5   3   3   2   3   3   4   4   5   5
Lake Charles LA     5   4   3   3   3   3   2   2   3   3   4   5
Phoenix AZ          4   4   4   4   4   2   2   2   2   2   4   4
Rapid City SD       3   3   3   4   4   3   2   2   2   2   4   4
Tacoma WA           6   6   5   4   4   4   4   4   4   4   6   6
Fairbanks AK        3   3   4   4   4   4   3   3   4   4   4   3
Hubbard Brook NH    5   5   5   4   4   4   4   4   4   5   5   5</code></pre><p>Apparently a default DURATN of 4 hours is appropriate for all months anywhere in the U.S. &quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_EVP.jl#LL546-L609">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.EVP.PLNTRES-NTuple{9, Any}" href="#LWFBrook90.EVP.PLNTRES-NTuple{9, Any}"><code>LWFBrook90.EVP.PLNTRES</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PLNTRES()</code></pre><p>Allocates total plant resistance to xylem and root layers.</p><p>Ecoshift: Subroutine PLNTRES is called at the beginning of each day to obtain resistivities to liquid water flow: rhizosphere resistivity for each soil layer, root resistivity in each soil layer, and xylem resistivity. These parameters, together with soil water potential in each layer (PSITI) and critical plant water potential (PSICR) control the supply of water to transpiring leaves and thus the reduction of actual transpiration below potential transpiration. As defined by Hunt et al. (1991) the resistances used here are &quot;potential difference resistivities&quot;, because the transpiration flux rate is in units of mm/d and the potential gradient is in MPa. The resistivities have units of MPa d mm-1.</p><p>In most of this subsection and the following subsection (TBYLAYER), algebraic notation is used instead of variable names. The correspondence is:</p><p>rri RROOTI()    ψt  PSIT    P   PTR fi  RTFRAC rx  RXYLEM  ψti PSITI() T   ATR Di  D() rp RPLANT  ψc  PSICR   Ti  ATRANI()    Li  RTDENI ri  RI          S   SUPPLY  δi  DELT rt  RT αi  ALPHA() The following additional parameters or constants are input to the routines</p><p>fx  FXYLEM  di  RELDEN  ρwg RHOWG R1  RTRAD   d   DISPC   π   PI Lr  RTLEN   Ki  KK()</p><p>Several other algebraic variables occur in the derivations below, but are not needed in the program.</p><p>If soil water potential is uniform through the root zone and rhizosphere resistivity is negligible, a bulk plant resistivity, rp, can be defined by</p><p>rp = ( ψt - ψ - ρw gd ) / T&#39;</p><p>where T&#39; is the transpiration rate, ψt is the soil water potential, and ψ is the leaf water potential. The ρwgd term is the gravity potential difference above the ground surface, where ρwg is the density of water times the acceleration of gravity, and d is the effective height of canopy evaporation, taken here as the closed canopy zero-plane displacement (DISPC). Change in water storage within the plant is ignored in BROOK90, as Hunt et al. (1991) have shown that it does not matter to total daily transpiration.</p><p>In BROOK90, rp is determined primarily by the maximum bulk plant conductivity (MXKPL), which is an input parameter. MXKPL is the water uptake rate for a closed canopy per unit of soil to leaf potential difference. When the soil is wet so ψt is close to 0, many plants have a ψ of around -1.5 MPa when transpiration rate is about 0.5 mm/hr, a normal midday rate for a sunny day in temperate regions. This gives a MXKPL of 8 mm d-1 MPa-1. Abdul-Jabbar et al. (1984) found literature values to range only from 7 to 30 mm d-1 MPa-1, which seems a surprisingly narrow range for plant canopies of any species. Actual plant resistivity, rp, is determined in subroutine CANOPY.</p><p>Fig. EVP-1. Resistances and potentials in the liquid flow path for transpiration, for 3 layers with roots. ψ is the leaf potential, ψx is potential at gorund level, and ψti are total soil water potentials. rₓ is xylem resistance, rᵣᵢ are root resistances, and rₛᵢ are rhizosphere resistances.</p><p>Figure EVP-1 shows the resistance network used in BROOK90. Each soil layer is considered to have a rhizosphere resistivity, rsi, and a root resistivity, rri, in series. Each layer is considered in parallel with the others. An additional resistivity in series accounts for resistance to flow through the xylem above ground level, rx. The total soil-water potential, ψti, differs among layers. The leaf water potential, ψ, is assumed constant through the canopy. The potential at the ground surface is ψx. This system and the parameterization of it was developed by Federer (1979) and Hunt and others(1991).</p><p>The xylem resistance, rx, is</p><p>rx = fx rp ;</p><p>where fx (FXYLEM) is an input parameter, which is probably close to zero for short canopies, but may be 0.5 or higher for forests (Hunt et al. 1991). The use of fx here specifies the amount of rp (RPLANT) that should not be divided among soil layers, so it is effectively the fraction of the plant resistance that is above ground level.</p><p>The plant resistance that is below ground level, rp - rx, is the parallel combination of the individual layer resistances, rri (Fig. EVP-1). BROOK90 assumes that the root resistivity per unit length of root is constant, so rri (RROOTI) is inversely proportional to the fraction of total root length that is in each layer, fi</p><p>rri = ( rp - rx ) / fi .</p><p>BROOK90 parameterizes root distribution by the relative density of roots in each soil layer di (RELDENi). RELDENi is obtained from ROOTDEN in subroutine RTDEN . Then fi is</p><p>fi = di Di / S ( di Di )</p><p>where Di is the stone-free layer thickness, THICK(i) * (1 - STONEF(i)).</p><p>When the soil is at uniform water potential and rhizosphere resistances, rsi , are negligible and fx = 0, then the relative transpiration withdrawal from each layer is proportional to fi (see subroutine TBYLAYER). Increasing fx makes the withdrawal less dependent on fi .</p><p>Usually the rhizosphere resistance only becomes significant when the soil is dry. Following Federer (1979) and Cowan (1965), the rhizosphere resistance, rsi , calculated in subroutine TBYLAYER is rsi = αi / Ki , where Ki is the hydraulic conductivity of the rhizosphere. The value of αi (ALPHAi) for a layer is</p><p>αi = Ai / ρwg Di</p><p>where Ai from Cowan (1965) is</p><p>Ai = ( 1 / 8 π Li ) [ δi - 3 - 2 ( ln δi ) / ( 1 - δi ) ]</p><p>where Li is the root density in the layer (mm/mm3) and δi is the root volume fraction in the layer, obtained as</p><p>δi = π R12 Li</p><p>where R1 is the average radius of the absorbing roots (RTRAD) , which is an input parameter. (Note that δi has no relation to the daylength, δ ). The root density is</p><p>Li = fi Lr / Di</p><p>where Lr is the total length of absorbing roots per unit ground area in mm/mm2. The value of Lr in m/m2 is found in subroutine CANOPY as the parameter MXRTLN reduced by DENSEF and RELHT. The dependence on the seasonal RELHT assumes that root length increases proportionally with height growth. MXRTLN is an input parameter expressing the length of absorbing roots per unit ground area in m/m2. Lr and R1 only affect rhizosphere resistance and thus are only important for dry soil or when Lr is small. &quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_EVP.jl#LL26-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LWFBrook90.EVP.TBYLAYER-NTuple{11, Any}" href="#LWFBrook90.EVP.TBYLAYER-NTuple{11, Any}"><code>LWFBrook90.EVP.TBYLAYER</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TBYLAYER()</code></pre><p>Allocate transporation among soil layers.</p><p>Ecoshift: TBYLAYER determines the rate at which liquid water can be supplied to transpiring leaves, compares this rate with the potential transpiration rate, sets actual transpiration equal to the lesser of the two, and then allocates the transpiration among soil layers. This routine is based on the model of Federer (1979), which has been widely used, e.g. Wetzel and Chang (1987), Levine and Salvucci (1999).</p><p>The routine requires iteration when outflow from roots is prevented for layers in which xylem potential ψx is greater than soil water potential ψti(Fig. EVP-1).</p><p>The resistance to uptake from each layer, ri, is</p><p>ri = rri + rsi = rri + αi / Ki</p><p>(Fig. EVP-1) where rri (RROOTI) and αi (ALPHAi) are variables from subroutine PLNTRES and Ki is the rhizosphere conductivity of the layer (Cowan 1965, Federer 1979). Estimating rhizosphere conductivity requires an iterative solution as described in Federer (1979), so BROOK90 uses the Ki (KKi) of the bulk soil instead. This tends to underestimate the rhizosphere resistance, but the error is probably unimportant unless rp is quite small. The total root resistance to uptake is</p><p>rt = 1 / Σ ( 1 / ri ) .</p><p>The transpiration rate for each layer, Ti , is</p><p>Ti = ( ψti - ψx ) / ri</p><p>where ψti is the total water potential for the layer (PSITI) , and ψx is the xylem potential. The total transpiration from all layers is</p><p>T = ΣTi = Σ( ψti / ri ) - ψx Σ ( 1 / ri ) = ( ψt - ψx ) / rt</p><p>where ψt is a weighted mean soil water potential defined as</p><p>ψt = rt Σ (ψti / ri ).</p><p>Eliminating ψx from the Ti and T equations gives</p><p>Ti = ( ψti - ψt + rt T ) / ri</p><p>which is the equation used to distribute T among layers.</p><p>In BROOK90 actual transpiration rate, T, is the lesser of potential transpiration rate, P, and the maximum possible rate of water uptake from the soil, S. Following Federer (1979) and Lynn and Carlson (1990), BROOK90 assumes that the S obtains when the leaf potential, ψ, is the critical potential at which stomates close, ψc , which is an input parameter (PSICR). The assumption that the T is the lesser of the P and S is equivalent to an assumption that stomatal opening is not limited by leaf water potential, ψ, until the critical potential, ψc, is reached. The stomata are then assumed to close as much as necessary to maintain ψ = ψc. This abrupt switch from a demand-limited to supply-limited regime is oversimplified, but is convenient for modeling. This type of behavior induces a flat-topped diurnal transpiration curve (Lynn and Carlson 1990). The critical potential, ψc, represents the maximum suction that the plant can exert to get water from the soil, the minimum soil-water potential that the plant can induce, and the lower limit of soil water availability.</p><p>The water supply rate, S, is the potential difference between leaf water potential, ψ, and the xylem potential, ψx, divided by the xylem resistance, rx , when ψ is equal to the critical potential, ψc (see Fig EVP-1). With allowance for the gravity potential between the ground and the canopy zero-plane displacement height, d (DISP), this is</p><p>S = ( ψx - ψc - ρw g d ) / rx</p><p>S below ground must be T = ( ψt - ψx ) / rt from above, and equating the two S equations to eliminating ψx, gives</p><p>S = ( ψt - ψc - ρw g d) / ( rt + rx )</p><p>which is assumed to be constant throughout a day.</p><p>Fig. EVP-2. Transpiration for the day, T&#39; (shaded area), as the lesser of a constant water  supply rate, S, and a half-sine potential transpiration, P&#39;.</p><p>Following Federer (1982), BROOK90 assumes that the daytime potential transpiration rate, P&#39;, varies as a half sine wave. The actual transpiration rate, T&#39; , is the lesser of S and P&#39; (Fig. EVP-2). The average value of T&#39; over the daytime, T, is</p><p>T = P ( 1 + R cos-1 R - sin (cos-1 R) )  R &lt; 1</p><p>T = P       R &gt;= 1</p><p>where</p><p>R = 2 S / π P</p><p>where P is the average of P&#39; over the daytime. (Notation here differs slightly from Federer (1982) who used S&#39; for S, D/d for P, and T/d for T where d is daylength.) At night, P is assumed constant and T is the lesser of S and P.</p><p>Normally, all layers with roots are included in the above calculations. However, when some layers are wet and others are dry, it is possible for ψti (PSITI) in one or more layers to be lower than ψx so that the roots in those layers are releasing water to the soil. The question of whether such outflow occurs or is somehow prevented by the roots is controversial (Hunt et al. 1991). More recent work shows that outflow does occur (Dawson 1993). Richards and Caldwell (1987) name the process &quot;hydraulic lift&quot; because it moves water upward from wetter deeper soil layers through the plant to shallow drier layers. In BROOK90 outflow from roots is prevented when the parameter NOOUTF is set to 1, and is allowed if NOOUTF is 0. In general, BROOK90 usually will work better when NOOUTF = 1; this is the default. When NOOUTF = 1 and any Ti is negative, the layer with the most negative Ti is eliminated and new values of rt , ψt , T, and Ti are obtained. If any Ti are still negative, the elimination process is repeated. This elimination procedure causes transpiration from a layer to cease when its potential is still greater than PSICR.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fabern/LWFBrook90.jl/blob/49ecce3719c9bce0cb19caaabb7005595c0a7f57/src/module_EVP.jl#LL180-L287">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../code-lst/">« Code Listing</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 17 February 2023 20:00">Friday 17 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
